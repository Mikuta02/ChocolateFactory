{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/render/canvas/ExecutorGroup\r\n */\n\nimport Executor from './Executor.js';\nimport { ascending } from '../../array.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty } from '../../obj.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n\n/**\r\n * @const\r\n * @type {Array<import(\"../canvas.js\").BuilderType>}\r\n */\nexport const ALL = ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'];\n\n/**\r\n * @const\r\n * @type {Array<import(\"../canvas.js\").BuilderType>}\r\n */\nexport const DECLUTTER = ['Image', 'Text'];\n\n/**\r\n * @const\r\n * @type {Array<import(\"../canvas.js\").BuilderType>}\r\n */\nexport const NON_DECLUTTER = ALL.filter(builderType => !DECLUTTER.includes(builderType));\nclass ExecutorGroup {\n  /**\r\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\r\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\r\n   * should be set here, unless the target context does not exceed that extent (which\r\n   * can be the case when rendering to tiles).\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\r\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\r\n   * The serializable instructions.\r\n   * @param {number} [renderBuffer] Optional rendering buffer.\r\n   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().\r\n   */\n  constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer, deferredRendering) {\n    /**\r\n     * @private\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.overlaps_ = overlaps;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.resolution_ = resolution;\n\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\n    this.renderBuffer_ = renderBuffer;\n\n    /**\r\n     * @private\r\n     * @type {!Object<string, !Object<string, import(\"./Executor\").default>>}\r\n     */\n    this.executorsByZIndex_ = {};\n\n    /**\r\n     * @private\r\n     * @type {CanvasRenderingContext2D}\r\n     */\n    this.hitDetectionContext_ = null;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\n    this.hitDetectionTransform_ = createTransform();\n\n    /**\r\n     * @private\r\n     * @type {CanvasRenderingContext2D}\r\n     */\n    this.renderedContext_ = null;\n\n    /**\r\n     * @type {Object<number, Array<import(\"./ZIndexContext.js\").default>>}\r\n     */\n    this.deferredZIndexContexts_ = {};\n    this.createExecutors_(allInstructions, deferredRendering);\n  }\n\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   */\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n\n  /**\r\n   * Create executors and populate them using the provided instructions.\r\n   * @private\r\n   * @param {!Object<string, !Object<string, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\r\n   * @param {boolean} deferredRendering Enable deferred rendering.\r\n   */\n  createExecutors_(allInstructions, deferredRendering) {\n    for (const zIndex in allInstructions) {\n      let executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      const instructionByZindex = allInstructions[zIndex];\n      for (const builderType in instructionByZindex) {\n        const instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, deferredRendering);\n      }\n    }\n  }\n\n  /**\r\n   * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\r\n   * @return {boolean} Has executors of the provided types.\r\n   */\n  hasExecutors(executors) {\n    for (const zIndex in this.executorsByZIndex_) {\n      const candidates = this.executorsByZIndex_[zIndex];\n      for (let i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} rotation Rotation.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\r\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\n  forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    const newContext = !this.hitDetectionContext_;\n    if (newContext) {\n      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize, undefined, {\n        willReadFrequently: true\n      });\n    }\n    const context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else if (!newContext) {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\n    let hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    const indexes = getPixelIndexArray(hitTolerance);\n    let builderType;\n\n    /**\r\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n     * @param {import('../../style/Style.js').DeclutterMode} declutterMode Declutter mode.\r\n     * @return {T|undefined} Callback result.\r\n     */\n    function featureCallback(feature, geometry, declutterMode) {\n      const imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (let i = 0, ii = indexes.length; i < ii; i++) {\n        if (imageData[indexes[i]] > 0) {\n          if (!declutteredFeatures || declutterMode === 'none' || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {\n            const idx = (indexes[i] - 3) / 4;\n            const x = hitTolerance - idx % contextSize;\n            const y = hitTolerance - (idx / contextSize | 0);\n            const result = callback(feature, geometry, x * x + y * y);\n            if (result) {\n              return result;\n            }\n          }\n          context.clearRect(0, 0, contextSize, contextSize);\n          break;\n        }\n      }\n      return undefined;\n    }\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n    let i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ALL.length - 1; j >= 0; --j) {\n        builderType = ALL[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @return {Array<number>|null} Clip coordinates.\r\n   */\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n\n  /**\r\n   * @return {boolean} Is empty.\r\n   */\n  isEmpty() {\n    return isEmpty(this.executorsByZIndex_);\n  }\n\n  /**\r\n   * @param {CanvasRenderingContext2D} targetContext Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {number} viewRotation View rotation.\r\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\r\n   * @param {Array<import(\"../canvas.js\").BuilderType>} [builderTypes] Ordered replay types to replay.\r\n   *     Default is {@link module:ol/render/replay~ALL}\r\n   * @param {import(\"rbush\").default|null} [declutterTree] Declutter tree.\r\n   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.\r\n   */\n  execute(targetContext, scaledCanvasSize, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(ascending);\n    builderTypes = builderTypes ? builderTypes : ALL;\n    const maxBuilderTypes = ALL.length;\n    let i, ii, j, jj, replays;\n    if (declutterTree) {\n      zs.reverse();\n    }\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        const builderType = builderTypes[j];\n        const replay = replays[builderType];\n        if (replay !== undefined) {\n          const zIndexContext = declutterTree === null ? undefined : replay.getZIndexContext();\n          const context = zIndexContext ? zIndexContext.getContext() : targetContext;\n          const requireClip = this.maxExtent_ && builderType !== 'Image' && builderType !== 'Text';\n          if (requireClip) {\n            context.save();\n            // setup clipping so that the parts of over-simplified geometries are not\n            // visible outside the current extent when panning\n            this.clip(context, transform);\n          }\n          if (!zIndexContext || builderType === 'Text' || builderType === 'Image') {\n            replay.execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree);\n          } else {\n            zIndexContext.pushFunction(context => replay.execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree));\n          }\n          if (requireClip) {\n            context.restore();\n          }\n          if (zIndexContext) {\n            zIndexContext.offset();\n            const index = zs[i] * maxBuilderTypes + j;\n            if (!this.deferredZIndexContexts_[index]) {\n              this.deferredZIndexContexts_[index] = [];\n            }\n            this.deferredZIndexContexts_[index].push(zIndexContext);\n          }\n        }\n      }\n    }\n    this.renderedContext_ = targetContext;\n  }\n  getDeferredZIndexContexts() {\n    return this.deferredZIndexContexts_;\n  }\n  getRenderedContext() {\n    return this.renderedContext_;\n  }\n  renderDeferred() {\n    const deferredZIndexContexts = this.deferredZIndexContexts_;\n    const zs = Object.keys(deferredZIndexContexts).map(Number).sort(ascending);\n    for (let i = 0, ii = zs.length; i < ii; ++i) {\n      deferredZIndexContexts[zs[i]].forEach(zIndexContext => {\n        zIndexContext.draw(this.renderedContext_); // FIXME Pass clip to replay for temporarily enabling clip\n        zIndexContext.clear();\n      });\n      deferredZIndexContexts[zs[i]].length = 0;\n    }\n  }\n}\n\n/**\r\n * This cache is used to store arrays of indexes for calculated pixel circles\r\n * to increase performance.\r\n * It is a static property to allow each Replaygroup to access it.\r\n * @type {Object<number, Array<number>>}\r\n */\nconst circlePixelIndexArrayCache = {};\n\n/**\r\n * This methods creates an array with indexes of all pixels within a circle,\r\n * ordered by how close they are to the center.\r\n * A cache is used to increase performance.\r\n * @param {number} radius Radius.\r\n * @return {Array<number>} An array with indexes within a circle.\r\n */\nexport function getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\n    return circlePixelIndexArrayCache[radius];\n  }\n  const size = radius * 2 + 1;\n  const maxDistanceSq = radius * radius;\n  const distances = new Array(maxDistanceSq + 1);\n  for (let i = 0; i <= radius; ++i) {\n    for (let j = 0; j <= radius; ++j) {\n      const distanceSq = i * i + j * j;\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n      let distance = distances[distanceSq];\n      if (!distance) {\n        distance = [];\n        distances[distanceSq] = distance;\n      }\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\n      if (i > 0) {\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\n      }\n      if (j > 0) {\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\n        if (i > 0) {\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\n        }\n      }\n    }\n  }\n  const pixelIndex = [];\n  for (let i = 0, ii = distances.length; i < ii; ++i) {\n    if (distances[i]) {\n      pixelIndex.push(...distances[i]);\n    }\n  }\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\nexport default ExecutorGroup;","map":{"version":3,"names":["Executor","ascending","buffer","createEmpty","extendCoordinate","compose","composeTransform","create","createTransform","createCanvasContext2D","isEmpty","transform2D","ALL","DECLUTTER","NON_DECLUTTER","filter","builderType","includes","ExecutorGroup","constructor","maxExtent","resolution","pixelRatio","overlaps","allInstructions","renderBuffer","deferredRendering","maxExtent_","overlaps_","pixelRatio_","resolution_","renderBuffer_","executorsByZIndex_","hitDetectionContext_","hitDetectionTransform_","renderedContext_","deferredZIndexContexts_","createExecutors_","clip","context","transform","flatClipCoords","getClipCoords","beginPath","moveTo","lineTo","zIndex","executors","undefined","instructionByZindex","instructions","hasExecutors","candidates","i","ii","length","forEachFeatureAtCoordinate","coordinate","rotation","hitTolerance","callback","declutteredFeatures","Math","round","contextSize","newContext","willReadFrequently","canvas","width","height","clearRect","hitExtent","indexes","getPixelIndexArray","featureCallback","feature","geometry","declutterMode","imageData","getImageData","data","idx","x","y","result","zs","Object","keys","map","Number","sort","j","executor","zIndexKey","toString","executeHitDetection","minX","minY","maxX","maxY","execute","targetContext","scaledCanvasSize","viewRotation","snapToPixel","builderTypes","declutterTree","maxBuilderTypes","jj","replays","reverse","replay","zIndexContext","getZIndexContext","getContext","requireClip","save","pushFunction","restore","offset","index","push","getDeferredZIndexContexts","getRenderedContext","renderDeferred","deferredZIndexContexts","forEach","draw","clear","circlePixelIndexArrayCache","radius","size","maxDistanceSq","distances","Array","distanceSq","distance","pixelIndex"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/render/canvas/ExecutorGroup.js"],"sourcesContent":["/**\r\n * @module ol/render/canvas/ExecutorGroup\r\n */\r\n\r\nimport Executor from './Executor.js';\r\nimport {ascending} from '../../array.js';\r\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\r\nimport {\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../../transform.js';\r\nimport {createCanvasContext2D} from '../../dom.js';\r\nimport {isEmpty} from '../../obj.js';\r\nimport {transform2D} from '../../geom/flat/transform.js';\r\n\r\n/**\r\n * @const\r\n * @type {Array<import(\"../canvas.js\").BuilderType>}\r\n */\r\nexport const ALL = [\r\n  'Polygon',\r\n  'Circle',\r\n  'LineString',\r\n  'Image',\r\n  'Text',\r\n  'Default',\r\n];\r\n\r\n/**\r\n * @const\r\n * @type {Array<import(\"../canvas.js\").BuilderType>}\r\n */\r\nexport const DECLUTTER = ['Image', 'Text'];\r\n\r\n/**\r\n * @const\r\n * @type {Array<import(\"../canvas.js\").BuilderType>}\r\n */\r\nexport const NON_DECLUTTER = ALL.filter(\r\n  (builderType) => !DECLUTTER.includes(builderType),\r\n);\r\n\r\nclass ExecutorGroup {\r\n  /**\r\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\r\n   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`\r\n   * should be set here, unless the target context does not exceed that extent (which\r\n   * can be the case when rendering to tiles).\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\r\n   * @param {!Object<string, !Object<import(\"../canvas.js\").BuilderType, import(\"../canvas.js\").SerializableInstructions>>} allInstructions\r\n   * The serializable instructions.\r\n   * @param {number} [renderBuffer] Optional rendering buffer.\r\n   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().\r\n   */\r\n  constructor(\r\n    maxExtent,\r\n    resolution,\r\n    pixelRatio,\r\n    overlaps,\r\n    allInstructions,\r\n    renderBuffer,\r\n    deferredRendering,\r\n  ) {\r\n    /**\r\n     * @private\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\r\n    this.maxExtent_ = maxExtent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.overlaps_ = overlaps;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.resolution_ = resolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.renderBuffer_ = renderBuffer;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, !Object<string, import(\"./Executor\").default>>}\r\n     */\r\n    this.executorsByZIndex_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.hitDetectionContext_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.hitDetectionTransform_ = createTransform();\r\n\r\n    /**\r\n     * @private\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.renderedContext_ = null;\r\n\r\n    /**\r\n     * @type {Object<number, Array<import(\"./ZIndexContext.js\").default>>}\r\n     */\r\n    this.deferredZIndexContexts_ = {};\r\n\r\n    this.createExecutors_(allInstructions, deferredRendering);\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   */\r\n  clip(context, transform) {\r\n    const flatClipCoords = this.getClipCoords(transform);\r\n    context.beginPath();\r\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\r\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\r\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\r\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\r\n    context.clip();\r\n  }\r\n\r\n  /**\r\n   * Create executors and populate them using the provided instructions.\r\n   * @private\r\n   * @param {!Object<string, !Object<string, import(\"../canvas.js\").SerializableInstructions>>} allInstructions The serializable instructions\r\n   * @param {boolean} deferredRendering Enable deferred rendering.\r\n   */\r\n  createExecutors_(allInstructions, deferredRendering) {\r\n    for (const zIndex in allInstructions) {\r\n      let executors = this.executorsByZIndex_[zIndex];\r\n      if (executors === undefined) {\r\n        executors = {};\r\n        this.executorsByZIndex_[zIndex] = executors;\r\n      }\r\n      const instructionByZindex = allInstructions[zIndex];\r\n      for (const builderType in instructionByZindex) {\r\n        const instructions = instructionByZindex[builderType];\r\n        executors[builderType] = new Executor(\r\n          this.resolution_,\r\n          this.pixelRatio_,\r\n          this.overlaps_,\r\n          instructions,\r\n          deferredRendering,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"../canvas.js\").BuilderType>} executors Executors.\r\n   * @return {boolean} Has executors of the provided types.\r\n   */\r\n  hasExecutors(executors) {\r\n    for (const zIndex in this.executorsByZIndex_) {\r\n      const candidates = this.executorsByZIndex_[zIndex];\r\n      for (let i = 0, ii = executors.length; i < ii; ++i) {\r\n        if (executors[i] in candidates) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} rotation Rotation.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, number): T} callback Feature callback.\r\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\r\n  forEachFeatureAtCoordinate(\r\n    coordinate,\r\n    resolution,\r\n    rotation,\r\n    hitTolerance,\r\n    callback,\r\n    declutteredFeatures,\r\n  ) {\r\n    hitTolerance = Math.round(hitTolerance);\r\n    const contextSize = hitTolerance * 2 + 1;\r\n    const transform = composeTransform(\r\n      this.hitDetectionTransform_,\r\n      hitTolerance + 0.5,\r\n      hitTolerance + 0.5,\r\n      1 / resolution,\r\n      -1 / resolution,\r\n      -rotation,\r\n      -coordinate[0],\r\n      -coordinate[1],\r\n    );\r\n\r\n    const newContext = !this.hitDetectionContext_;\r\n    if (newContext) {\r\n      this.hitDetectionContext_ = createCanvasContext2D(\r\n        contextSize,\r\n        contextSize,\r\n        undefined,\r\n        {willReadFrequently: true},\r\n      );\r\n    }\r\n    const context = this.hitDetectionContext_;\r\n\r\n    if (\r\n      context.canvas.width !== contextSize ||\r\n      context.canvas.height !== contextSize\r\n    ) {\r\n      context.canvas.width = contextSize;\r\n      context.canvas.height = contextSize;\r\n    } else if (!newContext) {\r\n      context.clearRect(0, 0, contextSize, contextSize);\r\n    }\r\n\r\n    /**\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\r\n    let hitExtent;\r\n    if (this.renderBuffer_ !== undefined) {\r\n      hitExtent = createEmpty();\r\n      extendCoordinate(hitExtent, coordinate);\r\n      buffer(\r\n        hitExtent,\r\n        resolution * (this.renderBuffer_ + hitTolerance),\r\n        hitExtent,\r\n      );\r\n    }\r\n\r\n    const indexes = getPixelIndexArray(hitTolerance);\r\n\r\n    let builderType;\r\n\r\n    /**\r\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\r\n     * @param {import('../../style/Style.js').DeclutterMode} declutterMode Declutter mode.\r\n     * @return {T|undefined} Callback result.\r\n     */\r\n    function featureCallback(feature, geometry, declutterMode) {\r\n      const imageData = context.getImageData(\r\n        0,\r\n        0,\r\n        contextSize,\r\n        contextSize,\r\n      ).data;\r\n      for (let i = 0, ii = indexes.length; i < ii; i++) {\r\n        if (imageData[indexes[i]] > 0) {\r\n          if (\r\n            !declutteredFeatures ||\r\n            declutterMode === 'none' ||\r\n            (builderType !== 'Image' && builderType !== 'Text') ||\r\n            declutteredFeatures.includes(feature)\r\n          ) {\r\n            const idx = (indexes[i] - 3) / 4;\r\n            const x = hitTolerance - (idx % contextSize);\r\n            const y = hitTolerance - ((idx / contextSize) | 0);\r\n            const result = callback(feature, geometry, x * x + y * y);\r\n            if (result) {\r\n              return result;\r\n            }\r\n          }\r\n          context.clearRect(0, 0, contextSize, contextSize);\r\n          break;\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** @type {Array<number>} */\r\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\r\n    zs.sort(ascending);\r\n\r\n    let i, j, executors, executor, result;\r\n    for (i = zs.length - 1; i >= 0; --i) {\r\n      const zIndexKey = zs[i].toString();\r\n      executors = this.executorsByZIndex_[zIndexKey];\r\n      for (j = ALL.length - 1; j >= 0; --j) {\r\n        builderType = ALL[j];\r\n        executor = executors[builderType];\r\n        if (executor !== undefined) {\r\n          result = executor.executeHitDetection(\r\n            context,\r\n            transform,\r\n            rotation,\r\n            featureCallback,\r\n            hitExtent,\r\n          );\r\n          if (result) {\r\n            return result;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @return {Array<number>|null} Clip coordinates.\r\n   */\r\n  getClipCoords(transform) {\r\n    const maxExtent = this.maxExtent_;\r\n    if (!maxExtent) {\r\n      return null;\r\n    }\r\n    const minX = maxExtent[0];\r\n    const minY = maxExtent[1];\r\n    const maxX = maxExtent[2];\r\n    const maxY = maxExtent[3];\r\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\r\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\r\n    return flatClipCoords;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Is empty.\r\n   */\r\n  isEmpty() {\r\n    return isEmpty(this.executorsByZIndex_);\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} targetContext Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {number} viewRotation View rotation.\r\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\r\n   * @param {Array<import(\"../canvas.js\").BuilderType>} [builderTypes] Ordered replay types to replay.\r\n   *     Default is {@link module:ol/render/replay~ALL}\r\n   * @param {import(\"rbush\").default|null} [declutterTree] Declutter tree.\r\n   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.\r\n   */\r\n  execute(\r\n    targetContext,\r\n    scaledCanvasSize,\r\n    transform,\r\n    viewRotation,\r\n    snapToPixel,\r\n    builderTypes,\r\n    declutterTree,\r\n  ) {\r\n    /** @type {Array<number>} */\r\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\r\n    zs.sort(ascending);\r\n\r\n    builderTypes = builderTypes ? builderTypes : ALL;\r\n    const maxBuilderTypes = ALL.length;\r\n    let i, ii, j, jj, replays;\r\n    if (declutterTree) {\r\n      zs.reverse();\r\n    }\r\n    for (i = 0, ii = zs.length; i < ii; ++i) {\r\n      const zIndexKey = zs[i].toString();\r\n      replays = this.executorsByZIndex_[zIndexKey];\r\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\r\n        const builderType = builderTypes[j];\r\n        const replay = replays[builderType];\r\n        if (replay !== undefined) {\r\n          const zIndexContext =\r\n            declutterTree === null ? undefined : replay.getZIndexContext();\r\n          const context = zIndexContext\r\n            ? zIndexContext.getContext()\r\n            : targetContext;\r\n          const requireClip =\r\n            this.maxExtent_ &&\r\n            builderType !== 'Image' &&\r\n            builderType !== 'Text';\r\n          if (requireClip) {\r\n            context.save();\r\n            // setup clipping so that the parts of over-simplified geometries are not\r\n            // visible outside the current extent when panning\r\n            this.clip(context, transform);\r\n          }\r\n          if (\r\n            !zIndexContext ||\r\n            builderType === 'Text' ||\r\n            builderType === 'Image'\r\n          ) {\r\n            replay.execute(\r\n              context,\r\n              scaledCanvasSize,\r\n              transform,\r\n              viewRotation,\r\n              snapToPixel,\r\n              declutterTree,\r\n            );\r\n          } else {\r\n            zIndexContext.pushFunction((context) =>\r\n              replay.execute(\r\n                context,\r\n                scaledCanvasSize,\r\n                transform,\r\n                viewRotation,\r\n                snapToPixel,\r\n                declutterTree,\r\n              ),\r\n            );\r\n          }\r\n          if (requireClip) {\r\n            context.restore();\r\n          }\r\n          if (zIndexContext) {\r\n            zIndexContext.offset();\r\n            const index = zs[i] * maxBuilderTypes + j;\r\n            if (!this.deferredZIndexContexts_[index]) {\r\n              this.deferredZIndexContexts_[index] = [];\r\n            }\r\n            this.deferredZIndexContexts_[index].push(zIndexContext);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedContext_ = targetContext;\r\n  }\r\n\r\n  getDeferredZIndexContexts() {\r\n    return this.deferredZIndexContexts_;\r\n  }\r\n\r\n  getRenderedContext() {\r\n    return this.renderedContext_;\r\n  }\r\n\r\n  renderDeferred() {\r\n    const deferredZIndexContexts = this.deferredZIndexContexts_;\r\n    const zs = Object.keys(deferredZIndexContexts).map(Number).sort(ascending);\r\n    for (let i = 0, ii = zs.length; i < ii; ++i) {\r\n      deferredZIndexContexts[zs[i]].forEach((zIndexContext) => {\r\n        zIndexContext.draw(this.renderedContext_); // FIXME Pass clip to replay for temporarily enabling clip\r\n        zIndexContext.clear();\r\n      });\r\n      deferredZIndexContexts[zs[i]].length = 0;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This cache is used to store arrays of indexes for calculated pixel circles\r\n * to increase performance.\r\n * It is a static property to allow each Replaygroup to access it.\r\n * @type {Object<number, Array<number>>}\r\n */\r\nconst circlePixelIndexArrayCache = {};\r\n\r\n/**\r\n * This methods creates an array with indexes of all pixels within a circle,\r\n * ordered by how close they are to the center.\r\n * A cache is used to increase performance.\r\n * @param {number} radius Radius.\r\n * @return {Array<number>} An array with indexes within a circle.\r\n */\r\nexport function getPixelIndexArray(radius) {\r\n  if (circlePixelIndexArrayCache[radius] !== undefined) {\r\n    return circlePixelIndexArrayCache[radius];\r\n  }\r\n\r\n  const size = radius * 2 + 1;\r\n  const maxDistanceSq = radius * radius;\r\n  const distances = new Array(maxDistanceSq + 1);\r\n  for (let i = 0; i <= radius; ++i) {\r\n    for (let j = 0; j <= radius; ++j) {\r\n      const distanceSq = i * i + j * j;\r\n      if (distanceSq > maxDistanceSq) {\r\n        break;\r\n      }\r\n      let distance = distances[distanceSq];\r\n      if (!distance) {\r\n        distance = [];\r\n        distances[distanceSq] = distance;\r\n      }\r\n      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);\r\n      if (i > 0) {\r\n        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);\r\n      }\r\n      if (j > 0) {\r\n        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);\r\n        if (i > 0) {\r\n          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const pixelIndex = [];\r\n  for (let i = 0, ii = distances.length; i < ii; ++i) {\r\n    if (distances[i]) {\r\n      pixelIndex.push(...distances[i]);\r\n    }\r\n  }\r\n\r\n  circlePixelIndexArrayCache[radius] = pixelIndex;\r\n  return pixelIndex;\r\n}\r\n\r\nexport default ExecutorGroup;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}