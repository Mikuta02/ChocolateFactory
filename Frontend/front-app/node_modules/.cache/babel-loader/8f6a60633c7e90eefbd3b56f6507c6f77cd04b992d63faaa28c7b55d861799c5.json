{"ast":null,"code":"/**\r\n * @module ol/ImageTile\r\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { listenImage } from './Image.js';\nclass ImageTile extends Tile {\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {string} src Image source URI.\r\n   * @param {?string} crossOrigin Cross origin.\r\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\r\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\r\n     * @private\r\n     * @type {?string}\r\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\r\n     * Image URI\r\n     *\r\n     * @private\r\n     * @type {string}\r\n     */\n    this.src_ = src;\n    this.key = src;\n\n    /**\r\n     * @private\r\n     * @type {HTMLImageElement|HTMLCanvasElement}\r\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\r\n     * @private\r\n     * @type {?function():void}\r\n     */\n    this.unlisten_ = null;\n\n    /**\r\n     * @private\r\n     * @type {import(\"./Tile.js\").LoadFunction}\r\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\r\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @api\r\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\r\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\r\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\r\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\r\n   * Tracks loading or read errors.\r\n   *\r\n   * @private\r\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\r\n   * Tracks successful image load.\r\n   *\r\n   * @private\r\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */this.image_;\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\r\n   * Load the image or retry if loading previously failed.\r\n   * Loading is taken care of by the tile queue, and calling this method is\r\n   * only needed for preloading or for reloading in case of an error.\r\n   *\r\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\r\n   * that checks for error status codes and reloads only when the status code is\r\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\r\n   * made already:\r\n   *\r\n   * ```js\r\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\r\n   * const retries = {};\r\n   * source.setTileLoadFunction((tile, src) => {\r\n   *   const image = tile.getImage();\r\n   *   fetch(src)\r\n   *     .then((response) => {\r\n   *       if (retryCodes.includes(response.status)) {\r\n   *         retries[src] = (retries[src] || 0) + 1;\r\n   *         if (retries[src] <= 3) {\r\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\r\n   *         }\r\n   *         return Promise.reject();\r\n   *       }\r\n   *       return response.blob();\r\n   *     })\r\n   *     .then((blob) => {\r\n   *       const imageUrl = URL.createObjectURL(blob);\r\n   *       image.src = imageUrl;\r\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\r\n   *     })\r\n   *     .catch(() => tile.setState(3)); // error\r\n   * });\r\n   * ```\r\n   *\r\n   * @api\r\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));\n    }\n  }\n\n  /**\r\n   * Discards event handlers which listen for load completion or errors.\r\n   *\r\n   * @private\r\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\r\n * Get a 1-pixel blank image.\r\n * @return {HTMLCanvasElement} Blank image.\r\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\nexport default ImageTile;","map":{"version":3,"names":["Tile","TileState","createCanvasContext2D","listenImage","ImageTile","constructor","tileCoord","state","src","crossOrigin","tileLoadFunction","options","crossOrigin_","src_","key","image_","Image","unlisten_","tileLoadFunction_","getImage","setImage","element","LOADED","unlistenImage_","changed","handleImageError_","ERROR","getBlankImage","handleImageLoad_","image","naturalWidth","naturalHeight","EMPTY","load","IDLE","LOADING","bind","ctx","fillStyle","fillRect","canvas"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/ImageTile.js"],"sourcesContent":["/**\r\n * @module ol/ImageTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\nimport {listenImage} from './Image.js';\r\n\r\nclass ImageTile extends Tile {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {string} src Image source URI.\r\n   * @param {?string} crossOrigin Cross origin.\r\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\r\n   */\r\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\r\n    super(tileCoord, state, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {?string}\r\n     */\r\n    this.crossOrigin_ = crossOrigin;\r\n\r\n    /**\r\n     * Image URI\r\n     *\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.src_ = src;\r\n\r\n    this.key = src;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLImageElement|HTMLCanvasElement}\r\n     */\r\n    this.image_ = new Image();\r\n    if (crossOrigin !== null) {\r\n      this.image_.crossOrigin = crossOrigin;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {?function():void}\r\n     */\r\n    this.unlisten_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./Tile.js\").LoadFunction}\r\n     */\r\n    this.tileLoadFunction_ = tileLoadFunction;\r\n  }\r\n\r\n  /**\r\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @api\r\n   */\r\n  getImage() {\r\n    return this.image_;\r\n  }\r\n\r\n  /**\r\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\r\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\r\n   */\r\n  setImage(element) {\r\n    this.image_ = element;\r\n    this.state = TileState.LOADED;\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks loading or read errors.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageError_() {\r\n    this.state = TileState.ERROR;\r\n    this.unlistenImage_();\r\n    this.image_ = getBlankImage();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks successful image load.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageLoad_() {\r\n    const image = /** @type {HTMLImageElement} */ (this.image_);\r\n    if (image.naturalWidth && image.naturalHeight) {\r\n      this.state = TileState.LOADED;\r\n    } else {\r\n      this.state = TileState.EMPTY;\r\n    }\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load the image or retry if loading previously failed.\r\n   * Loading is taken care of by the tile queue, and calling this method is\r\n   * only needed for preloading or for reloading in case of an error.\r\n   *\r\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\r\n   * that checks for error status codes and reloads only when the status code is\r\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\r\n   * made already:\r\n   *\r\n   * ```js\r\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\r\n   * const retries = {};\r\n   * source.setTileLoadFunction((tile, src) => {\r\n   *   const image = tile.getImage();\r\n   *   fetch(src)\r\n   *     .then((response) => {\r\n   *       if (retryCodes.includes(response.status)) {\r\n   *         retries[src] = (retries[src] || 0) + 1;\r\n   *         if (retries[src] <= 3) {\r\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\r\n   *         }\r\n   *         return Promise.reject();\r\n   *       }\r\n   *       return response.blob();\r\n   *     })\r\n   *     .then((blob) => {\r\n   *       const imageUrl = URL.createObjectURL(blob);\r\n   *       image.src = imageUrl;\r\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\r\n   *     })\r\n   *     .catch(() => tile.setState(3)); // error\r\n   * });\r\n   * ```\r\n   *\r\n   * @api\r\n   */\r\n  load() {\r\n    if (this.state == TileState.ERROR) {\r\n      this.state = TileState.IDLE;\r\n      this.image_ = new Image();\r\n      if (this.crossOrigin_ !== null) {\r\n        this.image_.crossOrigin = this.crossOrigin_;\r\n      }\r\n    }\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n      this.tileLoadFunction_(this, this.src_);\r\n      this.unlisten_ = listenImage(\r\n        this.image_,\r\n        this.handleImageLoad_.bind(this),\r\n        this.handleImageError_.bind(this),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Discards event handlers which listen for load completion or errors.\r\n   *\r\n   * @private\r\n   */\r\n  unlistenImage_() {\r\n    if (this.unlisten_) {\r\n      this.unlisten_();\r\n      this.unlisten_ = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get a 1-pixel blank image.\r\n * @return {HTMLCanvasElement} Blank image.\r\n */\r\nfunction getBlankImage() {\r\n  const ctx = createCanvasContext2D(1, 1);\r\n  ctx.fillStyle = 'rgba(0,0,0,0)';\r\n  ctx.fillRect(0, 0, 1, 1);\r\n  return ctx.canvas;\r\n}\r\n\r\nexport default ImageTile;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}