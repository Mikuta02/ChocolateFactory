{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/geom/flat/interpolate\r\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} fraction Fraction.\r\n * @param {Array<number>} [dest] Destination.\r\n * @param {number} [dimension] Destination dimension (default is `2`)\r\n * @return {Array<number>} Destination.\r\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} m M.\r\n * @param {boolean} extrapolate Extrapolate.\r\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\r\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = lo + hi >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} m M.\r\n * @param {boolean} extrapolate Extrapolate.\r\n * @param {boolean} interpolate Interpolate.\r\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\r\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    }\n    if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}","map":{"version":3,"names":["binarySearch","lerp","interpolatePoint","flatCoordinates","offset","end","stride","fraction","dest","dimension","o","t","n","x1","y1","length","cumulativeLengths","i","x2","y2","Math","sqrt","push","target","index","Array","undefined","NaN","lineStringCoordinateAtM","m","extrapolate","coordinate","slice","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","ends","interpolate","ii"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/geom/flat/interpolate.js"],"sourcesContent":["/**\r\n * @module ol/geom/flat/interpolate\r\n */\r\nimport {binarySearch} from '../../array.js';\r\nimport {lerp} from '../../math.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} fraction Fraction.\r\n * @param {Array<number>} [dest] Destination.\r\n * @param {number} [dimension] Destination dimension (default is `2`)\r\n * @return {Array<number>} Destination.\r\n */\r\nexport function interpolatePoint(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  fraction,\r\n  dest,\r\n  dimension,\r\n) {\r\n  let o, t;\r\n  const n = (end - offset) / stride;\r\n  if (n === 1) {\r\n    o = offset;\r\n  } else if (n === 2) {\r\n    o = offset;\r\n    t = fraction;\r\n  } else if (n !== 0) {\r\n    let x1 = flatCoordinates[offset];\r\n    let y1 = flatCoordinates[offset + 1];\r\n    let length = 0;\r\n    const cumulativeLengths = [0];\r\n    for (let i = offset + stride; i < end; i += stride) {\r\n      const x2 = flatCoordinates[i];\r\n      const y2 = flatCoordinates[i + 1];\r\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\r\n      cumulativeLengths.push(length);\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n    const target = fraction * length;\r\n    const index = binarySearch(cumulativeLengths, target);\r\n    if (index < 0) {\r\n      t =\r\n        (target - cumulativeLengths[-index - 2]) /\r\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\r\n      o = offset + (-index - 2) * stride;\r\n    } else {\r\n      o = offset + index * stride;\r\n    }\r\n  }\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  dest = dest ? dest : new Array(dimension);\r\n  for (let i = 0; i < dimension; ++i) {\r\n    dest[i] =\r\n      o === undefined\r\n        ? NaN\r\n        : t === undefined\r\n          ? flatCoordinates[o + i]\r\n          : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} m M.\r\n * @param {boolean} extrapolate Extrapolate.\r\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\r\n */\r\nexport function lineStringCoordinateAtM(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  m,\r\n  extrapolate,\r\n) {\r\n  if (end == offset) {\r\n    return null;\r\n  }\r\n  let coordinate;\r\n  if (m < flatCoordinates[offset + stride - 1]) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(offset, offset + stride);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    }\r\n    return null;\r\n  }\r\n  if (flatCoordinates[end - 1] < m) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(end - stride, end);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    }\r\n    return null;\r\n  }\r\n  // FIXME use O(1) search\r\n  if (m == flatCoordinates[offset + stride - 1]) {\r\n    return flatCoordinates.slice(offset, offset + stride);\r\n  }\r\n  let lo = offset / stride;\r\n  let hi = end / stride;\r\n  while (lo < hi) {\r\n    const mid = (lo + hi) >> 1;\r\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\r\n      hi = mid;\r\n    } else {\r\n      lo = mid + 1;\r\n    }\r\n  }\r\n  const m0 = flatCoordinates[lo * stride - 1];\r\n  if (m == m0) {\r\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\r\n  }\r\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\r\n  const t = (m - m0) / (m1 - m0);\r\n  coordinate = [];\r\n  for (let i = 0; i < stride - 1; ++i) {\r\n    coordinate.push(\r\n      lerp(\r\n        flatCoordinates[(lo - 1) * stride + i],\r\n        flatCoordinates[lo * stride + i],\r\n        t,\r\n      ),\r\n    );\r\n  }\r\n  coordinate.push(m);\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} m M.\r\n * @param {boolean} extrapolate Extrapolate.\r\n * @param {boolean} interpolate Interpolate.\r\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\r\n */\r\nexport function lineStringsCoordinateAtM(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  m,\r\n  extrapolate,\r\n  interpolate,\r\n) {\r\n  if (interpolate) {\r\n    return lineStringCoordinateAtM(\r\n      flatCoordinates,\r\n      offset,\r\n      ends[ends.length - 1],\r\n      stride,\r\n      m,\r\n      extrapolate,\r\n    );\r\n  }\r\n  let coordinate;\r\n  if (m < flatCoordinates[stride - 1]) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(0, stride);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    }\r\n    return null;\r\n  }\r\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\r\n    if (extrapolate) {\r\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\r\n      coordinate[stride - 1] = m;\r\n      return coordinate;\r\n    }\r\n    return null;\r\n  }\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    if (offset == end) {\r\n      continue;\r\n    }\r\n    if (m < flatCoordinates[offset + stride - 1]) {\r\n      return null;\r\n    }\r\n    if (m <= flatCoordinates[end - 1]) {\r\n      return lineStringCoordinateAtM(\r\n        flatCoordinates,\r\n        offset,\r\n        end,\r\n        stride,\r\n        m,\r\n        false,\r\n      );\r\n    }\r\n    offset = end;\r\n  }\r\n  return null;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}