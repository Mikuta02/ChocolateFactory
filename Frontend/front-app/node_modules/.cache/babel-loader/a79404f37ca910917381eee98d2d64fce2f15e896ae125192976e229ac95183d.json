{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/reproj/Tile\r\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection, getWidth, wrapAndSliceX } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n\n/**\r\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\r\n */\n\n/**\r\n * @typedef {Object} TileOffset\r\n * @property {import(\"../ImageTile.js\").default} tile Tile.\r\n * @property {number} offset Offset.\r\n */\n\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected tile.\r\n * See {@link module:ol/source/TileImage~TileImage}.\r\n *\r\n */\nclass ReprojTile extends Tile {\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} gutter Gutter of the source tiles.\r\n   * @param {FunctionType} getTileFunction\r\n   *     Function returning source tiles (z, x, y, pixelRatio).\r\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\r\n   * @param {boolean} [renderEdges] Render reprojection edges.\r\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\r\n   */\n  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.gutter_ = gutter;\n\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\n    this.canvas_ = null;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\r\n     * @private\r\n     * @type {!Array<TileOffset>}\r\n     */\n    this.sourceTiles_ = [];\n\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.sourceZ_ = 0;\n\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\n    this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : undefined;\n    const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n    const sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n    const errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor((sourceExtent[0] - sourceProjExtent[0]) / worldWidth);\n      }\n      const sourceExtents = wrapAndSliceX(sourceExtent.slice(), sourceProj, true);\n      sourceExtents.forEach(extent => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(extent, this.sourceZ_);\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({\n                tile,\n                offset\n              });\n            }\n          }\n        }\n        ++worldsAway;\n      });\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\r\n   * Get the HTML Canvas element for this tile.\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\r\n   * @private\r\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(source => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage()\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\r\n   * Load not yet loaded URI.\r\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      let leftToLoad = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({\n        tile\n      }) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n          const sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n            const state = tile.getState();\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({\n          tile\n        }, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\r\n   * @private\r\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\r\n   * Remove from the cache due to expiry\r\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\nexport default ReprojTile;","map":{"version":3,"names":["ERROR_THRESHOLD","EventType","Tile","TileState","Triangulation","calculateSourceExtentResolution","canvasPool","render","renderReprojected","clamp","getArea","getIntersection","getWidth","wrapAndSliceX","listen","unlistenByKey","releaseCanvas","ReprojTile","constructor","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","errorThreshold","renderEdges","options","IDLE","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","clipExtent_","canWrapX","getExtent","targetExtent","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","worldWidth","worldsAway","Math","floor","sourceExtents","slice","forEach","extent","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","offset","push","getImage","reproject_","sources","source","getState","LOADED","clipExtent","image","ERROR","z","size","getTileSize","width","height","interpolate","changed","load","LOADING","leftToLoad","sourceListenKey","CHANGE","e","unlistenSources_","setTimeout","bind","i","arr","release","getContext"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\r\n * @module ol/reproj/Tile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport Tile from '../Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceExtentResolution,\r\n  canvasPool,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\nimport {releaseCanvas} from '../dom.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\r\n */\r\n\r\n/**\r\n * @typedef {Object} TileOffset\r\n * @property {import(\"../ImageTile.js\").default} tile Tile.\r\n * @property {number} offset Offset.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected tile.\r\n * See {@link module:ol/source/TileImage~TileImage}.\r\n *\r\n */\r\nclass ReprojTile extends Tile {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} gutter Gutter of the source tiles.\r\n   * @param {FunctionType} getTileFunction\r\n   *     Function returning source tiles (z, x, y, pixelRatio).\r\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\r\n   * @param {boolean} [renderEdges] Render reprojection edges.\r\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    sourceTileGrid,\r\n    targetProj,\r\n    targetTileGrid,\r\n    tileCoord,\r\n    wrappedTileCoord,\r\n    pixelRatio,\r\n    gutter,\r\n    getTileFunction,\r\n    errorThreshold,\r\n    renderEdges,\r\n    options,\r\n  ) {\r\n    super(tileCoord, TileState.IDLE, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = gutter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<TileOffset>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.clipExtent_ = sourceProj.canWrapX()\r\n      ? sourceProj.getExtent()\r\n      : undefined;\r\n\r\n    const targetExtent = targetTileGrid.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = targetTileGrid.getResolution(\r\n      this.wrappedTileCoord_[0],\r\n    );\r\n\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution,\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      let worldWidth = 0;\r\n      let worldsAway = 0;\r\n      if (sourceProj.canWrapX()) {\r\n        worldWidth = getWidth(sourceProjExtent);\r\n        worldsAway = Math.floor(\r\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\r\n        );\r\n      }\r\n\r\n      const sourceExtents = wrapAndSliceX(\r\n        sourceExtent.slice(),\r\n        sourceProj,\r\n        true,\r\n      );\r\n      sourceExtents.forEach((extent) => {\r\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\r\n          extent,\r\n          this.sourceZ_,\r\n        );\r\n\r\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\r\n            if (tile) {\r\n              const offset = worldsAway * worldWidth;\r\n              this.sourceTiles_.push({tile, offset});\r\n            }\r\n          }\r\n        }\r\n        ++worldsAway;\r\n      });\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the HTML Canvas element for this tile.\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const sources = [];\r\n    this.sourceTiles_.forEach((source) => {\r\n      const tile = source.tile;\r\n      if (tile && tile.getState() == TileState.LOADED) {\r\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\r\n        extent[0] += source.offset;\r\n        extent[2] += source.offset;\r\n        const clipExtent = this.clipExtent_?.slice();\r\n        if (clipExtent) {\r\n          clipExtent[0] += source.offset;\r\n          clipExtent[2] += source.offset;\r\n        }\r\n        sources.push({\r\n          extent: extent,\r\n          clipExtent: clipExtent,\r\n          image: tile.getImage(),\r\n        });\r\n      }\r\n    });\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (sources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n    } else {\r\n      const z = this.wrappedTileCoord_[0];\r\n      const size = this.targetTileGrid_.getTileSize(z);\r\n      const width = typeof size === 'number' ? size : size[0];\r\n      const height = typeof size === 'number' ? size : size[1];\r\n      const targetResolution = this.targetTileGrid_.getResolution(z);\r\n      const sourceResolution = this.sourceTileGrid_.getResolution(\r\n        this.sourceZ_,\r\n      );\r\n\r\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n        this.wrappedTileCoord_,\r\n      );\r\n\r\n      this.canvas_ = renderReprojected(\r\n        width,\r\n        height,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        this.sourceTileGrid_.getExtent(),\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        this.renderEdges_,\r\n        this.interpolate,\r\n      );\r\n\r\n      this.state = TileState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   */\r\n  load() {\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n\r\n      let leftToLoad = 0;\r\n\r\n      this.sourcesListenerKeys_ = [];\r\n      this.sourceTiles_.forEach(({tile}) => {\r\n        const state = tile.getState();\r\n        if (state == TileState.IDLE || state == TileState.LOADING) {\r\n          leftToLoad++;\r\n\r\n          const sourceListenKey = listen(\r\n            tile,\r\n            EventType.CHANGE,\r\n            function (e) {\r\n              const state = tile.getState();\r\n              if (\r\n                state == TileState.LOADED ||\r\n                state == TileState.ERROR ||\r\n                state == TileState.EMPTY\r\n              ) {\r\n                unlistenByKey(sourceListenKey);\r\n                leftToLoad--;\r\n                if (leftToLoad === 0) {\r\n                  this.unlistenSources_();\r\n                  this.reproject_();\r\n                }\r\n              }\r\n            },\r\n            this,\r\n          );\r\n          this.sourcesListenerKeys_.push(sourceListenKey);\r\n        }\r\n      });\r\n\r\n      if (leftToLoad === 0) {\r\n        setTimeout(this.reproject_.bind(this), 0);\r\n      } else {\r\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\r\n          const state = tile.getState();\r\n          if (state == TileState.IDLE) {\r\n            tile.load();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n\r\n  /**\r\n   * Remove from the cache due to expiry\r\n   */\r\n  release() {\r\n    if (this.canvas_) {\r\n      releaseCanvas(this.canvas_.getContext('2d'));\r\n      canvasPool.push(this.canvas_);\r\n      this.canvas_ = null;\r\n    }\r\n    super.release();\r\n  }\r\n}\r\n\r\nexport default ReprojTile;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}