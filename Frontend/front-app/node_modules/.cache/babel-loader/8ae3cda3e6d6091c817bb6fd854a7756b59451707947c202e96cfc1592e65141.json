{"ast":null,"code":"/**\r\n * @module ol/geom/flat/transform\r\n */\n\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\nexport function transform2D(flatCoordinates, offset, end, stride, transform, dest) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const x = flatCoordinates[j];\n    const y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} angle Angle.\r\n * @param {Array<number>} anchor Rotation anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\nexport function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {\n  dest = dest ? dest : [];\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\r\n * Scale the coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} sx Scale factor in the x-direction.\r\n * @param {number} sy Scale factor in the y-direction.\r\n * @param {Array<number>} anchor Scale anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\nexport function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {\n  dest = dest ? dest : [];\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} deltaX Delta X.\r\n * @param {number} deltaY Delta Y.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\nexport function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}","map":{"version":3,"names":["transform2D","flatCoordinates","offset","end","stride","transform","dest","i","j","x","y","length","rotate","angle","anchor","cos","Math","sin","anchorX","anchorY","deltaX","deltaY","k","scale","sx","sy","translate"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/geom/flat/transform.js"],"sourcesContent":["/**\r\n * @module ol/geom/flat/transform\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function transform2D(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  transform,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const x = flatCoordinates[j];\r\n    const y = flatCoordinates[j + 1];\r\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\r\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} angle Angle.\r\n * @param {Array<number>} anchor Rotation anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function rotate(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  angle,\r\n  anchor,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  const cos = Math.cos(angle);\r\n  const sin = Math.sin(angle);\r\n  const anchorX = anchor[0];\r\n  const anchorY = anchor[1];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const deltaX = flatCoordinates[j] - anchorX;\r\n    const deltaY = flatCoordinates[j + 1] - anchorY;\r\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\r\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * Scale the coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} sx Scale factor in the x-direction.\r\n * @param {number} sy Scale factor in the y-direction.\r\n * @param {Array<number>} anchor Scale anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function scale(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  sx,\r\n  sy,\r\n  anchor,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  const anchorX = anchor[0];\r\n  const anchorY = anchor[1];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const deltaX = flatCoordinates[j] - anchorX;\r\n    const deltaY = flatCoordinates[j + 1] - anchorY;\r\n    dest[i++] = anchorX + sx * deltaX;\r\n    dest[i++] = anchorY + sy * deltaY;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} deltaX Delta X.\r\n * @param {number} deltaY Delta Y.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function translate(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  deltaX,\r\n  deltaY,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    dest[i++] = flatCoordinates[j] + deltaX;\r\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}