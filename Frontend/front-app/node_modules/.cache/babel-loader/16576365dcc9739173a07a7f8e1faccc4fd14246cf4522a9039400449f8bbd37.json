{"ast":null,"code":"/**\r\n * @module ol/resolutionconstraint\r\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n\n/**\r\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\r\n */\n\n/**\r\n * Returns a modified resolution taking into account the viewport size and maximum\r\n * allowed extent.\r\n * @param {number} resolution Resolution\r\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\r\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\r\n * @param {boolean} showFullExtent Whether to show the full extent.\r\n * @return {number} Capped resolution.\r\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\r\n * Returns a modified resolution to be between maxResolution and minResolution while\r\n * still allowing the value to be slightly out of bounds.\r\n * Note: the computation is based on the logarithm function (ln):\r\n *  - at 1, ln(x) is 0\r\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\r\n * The final result is clamped to prevent getting too far away from bounds.\r\n * @param {number} resolution Resolution.\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @return {number} Smoothed resolution.\r\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\r\n * @param {Array<number>} resolutions Resolutions.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\nexport function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\r\n * @param {number} power Power.\r\n * @param {number} maxResolution Maximum resolution.\r\n * @param {number} [minResolution] Minimum resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\nexport function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  minResolution = minResolution !== undefined ? minResolution : 0;\n  return (\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\nexport function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;\n        if (!smooth || !isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      }\n      return undefined;\n    }\n  );\n}","map":{"version":3,"names":["clamp","getHeight","getWidth","linearFindNearest","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","Math","min","max","getSmoothClampedResolution","maxResolution","minResolution","result","ratio","log","createSnapToResolutions","resolutions","smooth","undefined","direction","size","isMoving","length","cappedMaxRes","capped","z","floor","createSnapToPower","power","tolerance","minZoomLevel","ceil","offset","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/resolutionconstraint.js"],"sourcesContent":["/**\r\n * @module ol/resolutionconstraint\r\n */\r\nimport {clamp} from './math.js';\r\nimport {getHeight, getWidth} from './extent.js';\r\nimport {linearFindNearest} from './array.js';\r\n\r\n/**\r\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\r\n */\r\n\r\n/**\r\n * Returns a modified resolution taking into account the viewport size and maximum\r\n * allowed extent.\r\n * @param {number} resolution Resolution\r\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\r\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\r\n * @param {boolean} showFullExtent Whether to show the full extent.\r\n * @return {number} Capped resolution.\r\n */\r\nfunction getViewportClampedResolution(\r\n  resolution,\r\n  maxExtent,\r\n  viewportSize,\r\n  showFullExtent,\r\n) {\r\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\r\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\r\n\r\n  if (showFullExtent) {\r\n    return Math.min(resolution, Math.max(xResolution, yResolution));\r\n  }\r\n  return Math.min(resolution, Math.min(xResolution, yResolution));\r\n}\r\n\r\n/**\r\n * Returns a modified resolution to be between maxResolution and minResolution while\r\n * still allowing the value to be slightly out of bounds.\r\n * Note: the computation is based on the logarithm function (ln):\r\n *  - at 1, ln(x) is 0\r\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\r\n * The final result is clamped to prevent getting too far away from bounds.\r\n * @param {number} resolution Resolution.\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @return {number} Smoothed resolution.\r\n */\r\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\r\n  let result = Math.min(resolution, maxResolution);\r\n  const ratio = 50;\r\n\r\n  result *=\r\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\r\n    1;\r\n  if (minResolution) {\r\n    result = Math.max(result, minResolution);\r\n    result /=\r\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\r\n        ratio +\r\n      1;\r\n  }\r\n  return clamp(result, minResolution / 2, maxResolution * 2);\r\n}\r\n\r\n/**\r\n * @param {Array<number>} resolutions Resolutions.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createSnapToResolutions(\r\n  resolutions,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const maxResolution = resolutions[0];\r\n        const minResolution = resolutions[resolutions.length - 1];\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        // during interacting or animating, allow intermediary values\r\n        if (isMoving) {\r\n          if (!smooth) {\r\n            return clamp(resolution, minResolution, cappedMaxRes);\r\n          }\r\n          return getSmoothClampedResolution(\r\n            resolution,\r\n            cappedMaxRes,\r\n            minResolution,\r\n          );\r\n        }\r\n\r\n        const capped = Math.min(cappedMaxRes, resolution);\r\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\r\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\r\n          return resolutions[z + 1];\r\n        }\r\n        return resolutions[z];\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} power Power.\r\n * @param {number} maxResolution Maximum resolution.\r\n * @param {number} [minResolution] Minimum resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createSnapToPower(\r\n  power,\r\n  maxResolution,\r\n  minResolution,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n  minResolution = minResolution !== undefined ? minResolution : 0;\r\n\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        // during interacting or animating, allow intermediary values\r\n        if (isMoving) {\r\n          if (!smooth) {\r\n            return clamp(resolution, minResolution, cappedMaxRes);\r\n          }\r\n          return getSmoothClampedResolution(\r\n            resolution,\r\n            cappedMaxRes,\r\n            minResolution,\r\n          );\r\n        }\r\n\r\n        const tolerance = 1e-9;\r\n        const minZoomLevel = Math.ceil(\r\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance,\r\n        );\r\n        const offset = -direction * (0.5 - tolerance) + 0.5;\r\n        const capped = Math.min(cappedMaxRes, resolution);\r\n        const cappedZoomLevel = Math.floor(\r\n          Math.log(maxResolution / capped) / Math.log(power) + offset,\r\n        );\r\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\r\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\r\n        return clamp(newResolution, minResolution, cappedMaxRes);\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createMinMaxResolution(\r\n  maxResolution,\r\n  minResolution,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        if (!smooth || !isMoving) {\r\n          return clamp(resolution, minResolution, cappedMaxRes);\r\n        }\r\n        return getSmoothClampedResolution(\r\n          resolution,\r\n          cappedMaxRes,\r\n          minResolution,\r\n        );\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}