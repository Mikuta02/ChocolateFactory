{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/reproj/Triangulation\r\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { modulo } from '../math.js';\n\n/**\r\n * Single triangle; consists of 3 source points and 3 target points.\r\n * @typedef {Object} Triangle\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\r\n */\n\n/**\r\n * Maximum number of subdivision steps during raster reprojection triangulation.\r\n * Prevents high memory usage and large number of proj4 calls (for certain\r\n * transformations and areas). At most `2*(2^this)` triangles are created for\r\n * each triangulated extent (tile/image).\r\n * @type {number}\r\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\r\n * Maximum allowed size of triangle relative to world width. When transforming\r\n * corners of world extent between certain projections, the resulting\r\n * triangulation seems to have zero error and no subdivision is performed. If\r\n * the triangle width is more than this (relative to world width; 0-1),\r\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\r\n * @type {number}\r\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\r\n * @classdesc\r\n * Class containing triangulation of the given target extent.\r\n * Used for determining source data and the reprojection itself.\r\n */\nclass Triangulation {\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\r\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\r\n   * @param {number} errorThreshold Acceptable error (in source units).\r\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\r\n   */\n  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\r\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\r\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\r\n     * @private\r\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\r\n     * @type {Array<Triangle>}\r\n     * @private\r\n     */\n    this.triangles_ = [];\n\n    /**\r\n     * Indicates that the triangulation crosses edge of the source projection.\r\n     * @type {boolean}\r\n     * @private\r\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\r\n     * The maxSubdivision controls how many splittings of the target area can\r\n     * be done. The idea here is to do a linear mapping of the target areas\r\n     * but the actual overall reprojection (can be) extremely non-linear. The\r\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\r\n     * tile size. However this function is also called to remap canvas rendered\r\n     * layers which can be much larger. This calculation increases the maxSubdivision\r\n     * value by the right factor so that each 256x256 pixel area has\r\n     * MAX_SUBDIVISION divisions.\r\n     */\n    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(triangle => {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n          const newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          const maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n    transformInvCache = {};\n  }\n\n  /**\r\n   * Adds triangle to the triangulation.\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @private\r\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c]\n    });\n  }\n\n  /**\r\n   * Adds quad (points in clock-wise order) to the triangulation\r\n   * (and reprojects the vertices) if valid.\r\n   * Performs quad subdivision if needed to increase precision.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\r\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\r\n   * @private\r\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    const sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    let needsSubdivision = false;\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n    let isNotFinite = 0;\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n            return;\n          }\n        }\n      }\n    }\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n        return;\n      }\n    }\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\r\n   * Calculates extent of the `source` coordinates from all the triangles.\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\r\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n    return extent;\n  }\n\n  /**\r\n   * @return {Array<Triangle>} Array of the calculated triangles.\r\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\nexport default Triangulation;","map":{"version":3,"names":["boundingExtent","createEmpty","extendCoordinate","getArea","getBottomLeft","getBottomRight","getTopLeft","getTopRight","getWidth","intersects","getTransform","modulo","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","constructor","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","log2","addQuad_","leftBound","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/reproj/Triangulation.js"],"sourcesContent":["/**\r\n * @module ol/reproj/Triangulation\r\n */\r\nimport {\r\n  boundingExtent,\r\n  createEmpty,\r\n  extendCoordinate,\r\n  getArea,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n  getWidth,\r\n  intersects,\r\n} from '../extent.js';\r\nimport {getTransform} from '../proj.js';\r\nimport {modulo} from '../math.js';\r\n\r\n/**\r\n * Single triangle; consists of 3 source points and 3 target points.\r\n * @typedef {Object} Triangle\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\r\n */\r\n\r\n/**\r\n * Maximum number of subdivision steps during raster reprojection triangulation.\r\n * Prevents high memory usage and large number of proj4 calls (for certain\r\n * transformations and areas). At most `2*(2^this)` triangles are created for\r\n * each triangulated extent (tile/image).\r\n * @type {number}\r\n */\r\nconst MAX_SUBDIVISION = 10;\r\n\r\n/**\r\n * Maximum allowed size of triangle relative to world width. When transforming\r\n * corners of world extent between certain projections, the resulting\r\n * triangulation seems to have zero error and no subdivision is performed. If\r\n * the triangle width is more than this (relative to world width; 0-1),\r\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\r\n * @type {number}\r\n */\r\nconst MAX_TRIANGLE_WIDTH = 0.25;\r\n\r\n/**\r\n * @classdesc\r\n * Class containing triangulation of the given target extent.\r\n * Used for determining source data and the reprojection itself.\r\n */\r\nclass Triangulation {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\r\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\r\n   * @param {number} errorThreshold Acceptable error (in source units).\r\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    targetProj,\r\n    targetExtent,\r\n    maxSourceExtent,\r\n    errorThreshold,\r\n    destinationResolution,\r\n  ) {\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.sourceProj_ = sourceProj;\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.targetProj_ = targetProj;\r\n\r\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\r\n    let transformInvCache = {};\r\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\r\n\r\n    /**\r\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\r\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\r\n     * @private\r\n     */\r\n    this.transformInv_ = function (c) {\r\n      const key = c[0] + '/' + c[1];\r\n      if (!transformInvCache[key]) {\r\n        transformInvCache[key] = transformInv(c);\r\n      }\r\n      return transformInvCache[key];\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.maxSourceExtent_ = maxSourceExtent;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\r\n\r\n    /**\r\n     * @type {Array<Triangle>}\r\n     * @private\r\n     */\r\n    this.triangles_ = [];\r\n\r\n    /**\r\n     * Indicates that the triangulation crosses edge of the source projection.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.wrapsXInSource_ = false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.canWrapXInSource_ =\r\n      this.sourceProj_.canWrapX() &&\r\n      !!maxSourceExtent &&\r\n      !!this.sourceProj_.getExtent() &&\r\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\r\n      ? getWidth(this.sourceProj_.getExtent())\r\n      : null;\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\r\n      ? getWidth(this.targetProj_.getExtent())\r\n      : null;\r\n\r\n    const destinationTopLeft = getTopLeft(targetExtent);\r\n    const destinationTopRight = getTopRight(targetExtent);\r\n    const destinationBottomRight = getBottomRight(targetExtent);\r\n    const destinationBottomLeft = getBottomLeft(targetExtent);\r\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\r\n    const sourceTopRight = this.transformInv_(destinationTopRight);\r\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\r\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\r\n\r\n    /*\r\n     * The maxSubdivision controls how many splittings of the target area can\r\n     * be done. The idea here is to do a linear mapping of the target areas\r\n     * but the actual overall reprojection (can be) extremely non-linear. The\r\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\r\n     * tile size. However this function is also called to remap canvas rendered\r\n     * layers which can be much larger. This calculation increases the maxSubdivision\r\n     * value by the right factor so that each 256x256 pixel area has\r\n     * MAX_SUBDIVISION divisions.\r\n     */\r\n    const maxSubdivision =\r\n      MAX_SUBDIVISION +\r\n      (destinationResolution\r\n        ? Math.max(\r\n            0,\r\n            Math.ceil(\r\n              Math.log2(\r\n                getArea(targetExtent) /\r\n                  (destinationResolution * destinationResolution * 256 * 256),\r\n              ),\r\n            ),\r\n          )\r\n        : 0);\r\n\r\n    this.addQuad_(\r\n      destinationTopLeft,\r\n      destinationTopRight,\r\n      destinationBottomRight,\r\n      destinationBottomLeft,\r\n      sourceTopLeft,\r\n      sourceTopRight,\r\n      sourceBottomRight,\r\n      sourceBottomLeft,\r\n      maxSubdivision,\r\n    );\r\n\r\n    if (this.wrapsXInSource_) {\r\n      let leftBound = Infinity;\r\n      this.triangles_.forEach(function (triangle, i, arr) {\r\n        leftBound = Math.min(\r\n          leftBound,\r\n          triangle.source[0][0],\r\n          triangle.source[1][0],\r\n          triangle.source[2][0],\r\n        );\r\n      });\r\n\r\n      // Shift triangles to be as close to `leftBound` as possible\r\n      // (if the distance is more than `worldWidth / 2` it can be closer.\r\n      this.triangles_.forEach((triangle) => {\r\n        if (\r\n          Math.max(\r\n            triangle.source[0][0],\r\n            triangle.source[1][0],\r\n            triangle.source[2][0],\r\n          ) -\r\n            leftBound >\r\n          this.sourceWorldWidth_ / 2\r\n        ) {\r\n          const newTriangle = [\r\n            [triangle.source[0][0], triangle.source[0][1]],\r\n            [triangle.source[1][0], triangle.source[1][1]],\r\n            [triangle.source[2][0], triangle.source[2][1]],\r\n          ];\r\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[0][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[1][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[2][0] -= this.sourceWorldWidth_;\r\n          }\r\n\r\n          // Rarely (if the extent contains both the dateline and prime meridian)\r\n          // the shift can in turn break some triangles.\r\n          // Detect this here and don't shift in such cases.\r\n          const minX = Math.min(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0],\r\n          );\r\n          const maxX = Math.max(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0],\r\n          );\r\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\r\n            triangle.source = newTriangle;\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    transformInvCache = {};\r\n  }\r\n\r\n  /**\r\n   * Adds triangle to the triangulation.\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @private\r\n   */\r\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\r\n    this.triangles_.push({\r\n      source: [aSrc, bSrc, cSrc],\r\n      target: [a, b, c],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds quad (points in clock-wise order) to the triangulation\r\n   * (and reprojects the vertices) if valid.\r\n   * Performs quad subdivision if needed to increase precision.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\r\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\r\n   * @private\r\n   */\r\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\r\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\r\n    const sourceCoverageX = this.sourceWorldWidth_\r\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\r\n      : null;\r\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\r\n\r\n    // when the quad is wrapped in the source projection\r\n    // it covers most of the projection extent, but not fully\r\n    const wrapsX =\r\n      this.sourceProj_.canWrapX() &&\r\n      sourceCoverageX > 0.5 &&\r\n      sourceCoverageX < 1;\r\n\r\n    let needsSubdivision = false;\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\r\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\r\n        const targetCoverageX =\r\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\r\n        needsSubdivision =\r\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\r\n        needsSubdivision =\r\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n    }\r\n\r\n    if (!needsSubdivision && this.maxSourceExtent_) {\r\n      if (\r\n        isFinite(sourceQuadExtent[0]) &&\r\n        isFinite(sourceQuadExtent[1]) &&\r\n        isFinite(sourceQuadExtent[2]) &&\r\n        isFinite(sourceQuadExtent[3])\r\n      ) {\r\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\r\n          // whole quad outside source projection extent -> ignore\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    let isNotFinite = 0;\r\n\r\n    if (!needsSubdivision) {\r\n      if (\r\n        !isFinite(aSrc[0]) ||\r\n        !isFinite(aSrc[1]) ||\r\n        !isFinite(bSrc[0]) ||\r\n        !isFinite(bSrc[1]) ||\r\n        !isFinite(cSrc[0]) ||\r\n        !isFinite(cSrc[1]) ||\r\n        !isFinite(dSrc[0]) ||\r\n        !isFinite(dSrc[1])\r\n      ) {\r\n        if (maxSubdivision > 0) {\r\n          needsSubdivision = true;\r\n        } else {\r\n          // It might be the case that only 1 of the points is infinite. In this case\r\n          // we can draw a single triangle with the other three points\r\n          isNotFinite =\r\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\r\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\r\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\r\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\r\n          if (\r\n            isNotFinite != 1 &&\r\n            isNotFinite != 2 &&\r\n            isNotFinite != 4 &&\r\n            isNotFinite != 8\r\n          ) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (!needsSubdivision) {\r\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\r\n        const centerSrc = this.transformInv_(center);\r\n\r\n        let dx;\r\n        if (wrapsX) {\r\n          const centerSrcEstimX =\r\n            (modulo(aSrc[0], sourceWorldWidth) +\r\n              modulo(cSrc[0], sourceWorldWidth)) /\r\n            2;\r\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\r\n        } else {\r\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\r\n        }\r\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\r\n        const centerSrcErrorSquared = dx * dx + dy * dy;\r\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\r\n      }\r\n      if (needsSubdivision) {\r\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\r\n          // split horizontally (top & bottom)\r\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\r\n          const bcSrc = this.transformInv_(bc);\r\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\r\n          const daSrc = this.transformInv_(da);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            b,\r\n            bc,\r\n            da,\r\n            aSrc,\r\n            bSrc,\r\n            bcSrc,\r\n            daSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n          this.addQuad_(\r\n            da,\r\n            bc,\r\n            c,\r\n            d,\r\n            daSrc,\r\n            bcSrc,\r\n            cSrc,\r\n            dSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n        } else {\r\n          // split vertically (left & right)\r\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\r\n          const abSrc = this.transformInv_(ab);\r\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\r\n          const cdSrc = this.transformInv_(cd);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            ab,\r\n            cd,\r\n            d,\r\n            aSrc,\r\n            abSrc,\r\n            cdSrc,\r\n            dSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n          this.addQuad_(\r\n            ab,\r\n            b,\r\n            c,\r\n            cd,\r\n            abSrc,\r\n            bSrc,\r\n            cSrc,\r\n            cdSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (wrapsX) {\r\n      if (!this.canWrapXInSource_) {\r\n        return;\r\n      }\r\n      this.wrapsXInSource_ = true;\r\n    }\r\n\r\n    // Exactly zero or one of *Src is not finite\r\n    // The triangles must have the diagonal line as the first side\r\n    // This is to allow easy code in reproj.s to make it straight for broken\r\n    // browsers that can't handle diagonal clipping\r\n    if ((isNotFinite & 0xb) == 0) {\r\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\r\n    }\r\n    if ((isNotFinite & 0xe) == 0) {\r\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\r\n    }\r\n    if (isNotFinite) {\r\n      // Try the other two triangles\r\n      if ((isNotFinite & 0xd) == 0) {\r\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\r\n      }\r\n      if ((isNotFinite & 0x7) == 0) {\r\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates extent of the `source` coordinates from all the triangles.\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\r\n   */\r\n  calculateSourceExtent() {\r\n    const extent = createEmpty();\r\n\r\n    this.triangles_.forEach(function (triangle, i, arr) {\r\n      const src = triangle.source;\r\n      extendCoordinate(extent, src[0]);\r\n      extendCoordinate(extent, src[1]);\r\n      extendCoordinate(extent, src[2]);\r\n    });\r\n\r\n    return extent;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Triangle>} Array of the calculated triangles.\r\n   */\r\n  getTriangles() {\r\n    return this.triangles_;\r\n  }\r\n}\r\n\r\nexport default Triangulation;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}