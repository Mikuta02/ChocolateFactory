{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/geom/MultiPolygon\r\n */\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n\n/**\r\n * @classdesc\r\n * Multi-polygon geometry.\r\n *\r\n * @api\r\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\r\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\r\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\r\n     * @type {Array<Array<number>>}\r\n     * @private\r\n     */\n    this.endss_ = [];\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.maxDelta_ = -1;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.orientedRevision_ = -1;\n\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\n    this.orientedFlatCoordinates_ = null;\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons = /** @type {Array<Polygon>} */coordinates;\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates( /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */\n      coordinates, layout);\n    }\n  }\n\n  /**\r\n   * Append the passed polygon to this multipolygon.\r\n   * @param {Polygon} polygon Polygon.\r\n   * @api\r\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!MultiPolygon} Clone.\r\n   * @api\r\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n    const multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n    multiPolygon.applyProperties(this);\n    return multiPolygon;\n  }\n\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  }\n\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  }\n\n  /**\r\n   * Return the area of the multipolygon on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\n  getArea() {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  }\n\n  /**\r\n   * Get the coordinate array for this geometry.  This array has the structure\r\n   * of a GeoJSON coordinate array for multi-polygons.\r\n   *\r\n   * @param {boolean} [right] Orient coordinates according to the right-hand\r\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\r\n   *     If `false`, coordinates will be oriented according to the left-hand rule\r\n   *     (clockwise for exterior and counter-clockwise for interior rings).\r\n   *     By default, coordinate orientation will depend on how the geometry was\r\n   *     constructed.\r\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\r\n   * @api\r\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n  }\n\n  /**\r\n   * @return {Array<Array<number>>} Endss.\r\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\r\n   * @return {Array<number>} Flat interior points.\r\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */this.flatInteriorPoints_;\n  }\n\n  /**\r\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\r\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\r\n   * the length of the horizontal intersection that the point belongs to.\r\n   * @api\r\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\r\n   * @return {Array<number>} Oriented flat coordinates.\r\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */this.orientedFlatCoordinates_;\n  }\n\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {MultiPolygon} Simplified MultiPolygon.\r\n   * @protected\r\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\r\n   * Return the polygon at the specified index.\r\n   * @param {number} index Index.\r\n   * @return {Polygon} Polygon.\r\n   * @api\r\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  }\n\n  /**\r\n   * Return the polygons of this multipolygon.\r\n   * @return {Array<Polygon>} Polygons.\r\n   * @api\r\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  }\n\n  /**\r\n   * Set the coordinates of the multipolygon.\r\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\nexport default MultiPolygon;","map":{"version":3,"names":["MultiPoint","Polygon","SimpleGeometry","assignClosestMultiArrayPoint","multiArrayMaxSquaredDelta","closestSquaredDistanceXY","deflateMultiCoordinatesArray","extend","getInteriorPointsOfMultiArray","inflateMultiCoordinatesArray","intersectsLinearRingMultiArray","linearRingssAreOriented","orientLinearRingsArray","linearRingss","linearRingssArea","linearRingssCenter","linearRingssContainsXY","quantizeMultiArray","MultiPolygon","constructor","coordinates","layout","endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","Array","isArray","polygons","flatCoordinates","thisEndss","i","ii","length","polygon","offset","ends","getEnds","j","jj","getFlatCoordinates","push","getLayout","undefined","setFlatCoordinates","setCoordinates","appendPolygon","slice","changed","clone","len","newEndss","multiPolygon","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getOrientedFlatCoordinates","containsXY","getArea","getCoordinates","right","getEndss","getFlatInteriorPoints","flatCenters","getInteriorPoints","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","getPolygon","index","prevEnds","end","getPolygons","getType","intersectsExtent","extent","setLayout","lastEnds"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/geom/MultiPolygon.js"],"sourcesContent":["/**\r\n * @module ol/geom/MultiPolygon\r\n */\r\nimport MultiPoint from './MultiPoint.js';\r\nimport Polygon from './Polygon.js';\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {\r\n  assignClosestMultiArrayPoint,\r\n  multiArrayMaxSquaredDelta,\r\n} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY} from '../extent.js';\r\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\r\nimport {extend} from '../array.js';\r\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\r\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\r\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\r\nimport {\r\n  linearRingssAreOriented,\r\n  orientLinearRingsArray,\r\n} from './flat/orient.js';\r\nimport {linearRingss as linearRingssArea} from './flat/area.js';\r\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\r\nimport {linearRingssContainsXY} from './flat/contains.js';\r\nimport {quantizeMultiArray} from './flat/simplify.js';\r\n\r\n/**\r\n * @classdesc\r\n * Multi-polygon geometry.\r\n *\r\n * @api\r\n */\r\nclass MultiPolygon extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\r\n   */\r\n  constructor(coordinates, layout, endss) {\r\n    super();\r\n\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     * @private\r\n     */\r\n    this.endss_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.flatInteriorPointsRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\r\n    this.flatInteriorPoints_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.orientedRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\r\n    this.orientedFlatCoordinates_ = null;\r\n\r\n    if (!endss && !Array.isArray(coordinates[0])) {\r\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\r\n      /** @type {Array<number>} */\r\n      const flatCoordinates = [];\r\n      const thisEndss = [];\r\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\r\n        const polygon = polygons[i];\r\n        const offset = flatCoordinates.length;\r\n        const ends = polygon.getEnds();\r\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n          ends[j] += offset;\r\n        }\r\n        extend(flatCoordinates, polygon.getFlatCoordinates());\r\n        thisEndss.push(ends);\r\n      }\r\n      layout =\r\n        polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\r\n      coordinates = flatCoordinates;\r\n      endss = thisEndss;\r\n    }\r\n    if (layout !== undefined && endss) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates),\r\n      );\r\n      this.endss_ = endss;\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\r\n          coordinates\r\n        ),\r\n        layout,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed polygon to this multipolygon.\r\n   * @param {Polygon} polygon Polygon.\r\n   * @api\r\n   */\r\n  appendPolygon(polygon) {\r\n    /** @type {Array<number>} */\r\n    let ends;\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\r\n      ends = polygon.getEnds().slice();\r\n      this.endss_.push();\r\n    } else {\r\n      const offset = this.flatCoordinates.length;\r\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\r\n      ends = polygon.getEnds().slice();\r\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n        ends[i] += offset;\r\n      }\r\n    }\r\n    this.endss_.push(ends);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!MultiPolygon} Clone.\r\n   * @api\r\n   */\r\n  clone() {\r\n    const len = this.endss_.length;\r\n    const newEndss = new Array(len);\r\n    for (let i = 0; i < len; ++i) {\r\n      newEndss[i] = this.endss_[i].slice();\r\n    }\r\n\r\n    const multiPolygon = new MultiPolygon(\r\n      this.flatCoordinates.slice(),\r\n      this.layout,\r\n      newEndss,\r\n    );\r\n    multiPolygon.applyProperties(this);\r\n\r\n    return multiPolygon;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        multiArrayMaxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.endss_,\r\n          this.stride,\r\n          0,\r\n        ),\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestMultiArrayPoint(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   */\r\n  containsXY(x, y) {\r\n    return linearRingssContainsXY(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the multipolygon on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingssArea(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the coordinate array for this geometry.  This array has the structure\r\n   * of a GeoJSON coordinate array for multi-polygons.\r\n   *\r\n   * @param {boolean} [right] Orient coordinates according to the right-hand\r\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\r\n   *     If `false`, coordinates will be oriented according to the left-hand rule\r\n   *     (clockwise for exterior and counter-clockwise for interior rings).\r\n   *     By default, coordinate orientation will depend on how the geometry was\r\n   *     constructed.\r\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\r\n   * @api\r\n   */\r\n  getCoordinates(right) {\r\n    let flatCoordinates;\r\n    if (right !== undefined) {\r\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\r\n      orientLinearRingsArray(\r\n        flatCoordinates,\r\n        0,\r\n        this.endss_,\r\n        this.stride,\r\n        right,\r\n      );\r\n    } else {\r\n      flatCoordinates = this.flatCoordinates;\r\n    }\r\n\r\n    return inflateMultiCoordinatesArray(\r\n      flatCoordinates,\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Array<number>>} Endss.\r\n   */\r\n  getEndss() {\r\n    return this.endss_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Flat interior points.\r\n   */\r\n  getFlatInteriorPoints() {\r\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\r\n      const flatCenters = linearRingssCenter(\r\n        this.flatCoordinates,\r\n        0,\r\n        this.endss_,\r\n        this.stride,\r\n      );\r\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\r\n        this.getOrientedFlatCoordinates(),\r\n        0,\r\n        this.endss_,\r\n        this.stride,\r\n        flatCenters,\r\n      );\r\n      this.flatInteriorPointsRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {Array<number>} */ (this.flatInteriorPoints_);\r\n  }\r\n\r\n  /**\r\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\r\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\r\n   * the length of the horizontal intersection that the point belongs to.\r\n   * @api\r\n   */\r\n  getInteriorPoints() {\r\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Oriented flat coordinates.\r\n   */\r\n  getOrientedFlatCoordinates() {\r\n    if (this.orientedRevision_ != this.getRevision()) {\r\n      const flatCoordinates = this.flatCoordinates;\r\n      if (\r\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\r\n      ) {\r\n        this.orientedFlatCoordinates_ = flatCoordinates;\r\n      } else {\r\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\r\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\r\n          this.orientedFlatCoordinates_,\r\n          0,\r\n          this.endss_,\r\n          this.stride,\r\n        );\r\n      }\r\n      this.orientedRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {MultiPolygon} Simplified MultiPolygon.\r\n   * @protected\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    /** @type {Array<number>} */\r\n    const simplifiedFlatCoordinates = [];\r\n    /** @type {Array<Array<number>>} */\r\n    const simplifiedEndss = [];\r\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      Math.sqrt(squaredTolerance),\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n      simplifiedEndss,\r\n    );\r\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\r\n  }\r\n\r\n  /**\r\n   * Return the polygon at the specified index.\r\n   * @param {number} index Index.\r\n   * @return {Polygon} Polygon.\r\n   * @api\r\n   */\r\n  getPolygon(index) {\r\n    if (index < 0 || this.endss_.length <= index) {\r\n      return null;\r\n    }\r\n    let offset;\r\n    if (index === 0) {\r\n      offset = 0;\r\n    } else {\r\n      const prevEnds = this.endss_[index - 1];\r\n      offset = prevEnds[prevEnds.length - 1];\r\n    }\r\n    const ends = this.endss_[index].slice();\r\n    const end = ends[ends.length - 1];\r\n    if (offset !== 0) {\r\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n        ends[i] -= offset;\r\n      }\r\n    }\r\n    return new Polygon(\r\n      this.flatCoordinates.slice(offset, end),\r\n      this.layout,\r\n      ends,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the polygons of this multipolygon.\r\n   * @return {Array<Polygon>} Polygons.\r\n   * @api\r\n   */\r\n  getPolygons() {\r\n    const layout = this.layout;\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const endss = this.endss_;\r\n    const polygons = [];\r\n    let offset = 0;\r\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n      const ends = endss[i].slice();\r\n      const end = ends[ends.length - 1];\r\n      if (offset !== 0) {\r\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n          ends[j] -= offset;\r\n        }\r\n      }\r\n      const polygon = new Polygon(\r\n        flatCoordinates.slice(offset, end),\r\n        layout,\r\n        ends,\r\n      );\r\n      polygons.push(polygon);\r\n      offset = end;\r\n    }\r\n    return polygons;\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   */\r\n  getType() {\r\n    return 'MultiPolygon';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   */\r\n  intersectsExtent(extent) {\r\n    return intersectsLinearRingMultiArray(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.endss_,\r\n      this.stride,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the multipolygon.\r\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 3);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    const endss = deflateMultiCoordinatesArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n      this.endss_,\r\n    );\r\n    if (endss.length === 0) {\r\n      this.flatCoordinates.length = 0;\r\n    } else {\r\n      const lastEnds = endss[endss.length - 1];\r\n      this.flatCoordinates.length =\r\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\r\n    }\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default MultiPolygon;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}