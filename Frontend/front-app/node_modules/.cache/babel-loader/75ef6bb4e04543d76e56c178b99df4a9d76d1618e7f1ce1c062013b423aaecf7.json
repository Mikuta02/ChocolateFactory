{"ast":null,"code":"/**\r\n * @module ol/renderer/Layer\r\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport { abstract } from '../util.js';\n\n/**\r\n * @template {import(\"../layer/Layer.js\").default} LayerType\r\n */\nclass LayerRenderer extends Observable {\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\n  constructor(layer) {\n    super();\n\n    /**\r\n     * The renderer is initialized and ready to render.\r\n     * @type {boolean}\r\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\r\n     * @protected\r\n     * @type {LayerType}\r\n     */\n    this.layer_ = layer;\n  }\n\n  /**\r\n   * Asynchronous layer level hit detection.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\r\n   * an array of features.\r\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\r\n   * Determine whether render should be called.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\r\n   * Render the layer.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement|null} target Target that may be used to render content to.\r\n   * @return {HTMLElement|null} The rendered element.\r\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @param {import(\"../Tile.js\").default} tile Tile.\r\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\r\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\r\n   * Create a function that adds loaded tiles to the tile lookup.\r\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\r\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\r\n   * @protected\r\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\r\n       * @param {number} zoom Zoom level.\r\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n       * @return {boolean} The tile range is fully loaded.\r\n       */\n      (zoom, tileRange) => {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  }\n  /**\r\n   * @abstract\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\r\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    return undefined;\n  }\n\n  /**\r\n   * @return {LayerType} Layer.\r\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\r\n   * Perform action necessary to get the layer rendered after new fonts have loaded\r\n   * @abstract\r\n   */\n  handleFontsChanged() {}\n\n  /**\r\n   * Handle changes in image state.\r\n   * @param {import(\"../events/Event.js\").default} event Image change event.\r\n   * @private\r\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */event.target;\n    if (image.getState() === ImageState.LOADED || image.getState() === ImageState.ERROR) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\r\n   * Load the image if not already loaded, and register the image change\r\n   * listener if needed.\r\n   * @param {import(\"../Image.js\").default} image Image.\r\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\r\n   * @protected\r\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\r\n   * @protected\r\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\n  renderDeferred(frameState) {}\n\n  /**\r\n   * Clean up.\r\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\nexport default LayerRenderer;","map":{"version":3,"names":["EventType","ImageState","Observable","abstract","LayerRenderer","constructor","layer","ready","boundHandleImageChange_","handleImageChange_","bind","layer_","getFeatures","pixel","getData","prepareFrame","frameState","renderFrame","target","loadedTileCallback","tiles","zoom","tile","tileCoord","toString","undefined","createLoadedTileFinder","source","projection","tileRange","callback","forEachLoadedTile","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","getLayer","handleFontsChanged","event","image","getState","LOADED","ERROR","renderIfReadyAndVisible","loadImage","imageState","addEventListener","CHANGE","IDLE","load","getVisible","getSourceState","changed","renderDeferred","disposeInternal"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/renderer/Layer.js"],"sourcesContent":["/**\r\n * @module ol/renderer/Layer\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport Observable from '../Observable.js';\r\nimport {abstract} from '../util.js';\r\n\r\n/**\r\n * @template {import(\"../layer/Layer.js\").default} LayerType\r\n */\r\nclass LayerRenderer extends Observable {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\r\n  constructor(layer) {\r\n    super();\r\n\r\n    /**\r\n     * The renderer is initialized and ready to render.\r\n     * @type {boolean}\r\n     */\r\n    this.ready = true;\r\n\r\n    /** @private */\r\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {LayerType}\r\n     */\r\n    this.layer_ = layer;\r\n  }\r\n\r\n  /**\r\n   * Asynchronous layer level hit detection.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\r\n   * an array of features.\r\n   */\r\n  getFeatures(pixel) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\r\n  getData(pixel) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\r\n  prepareFrame(frameState) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement|null} target Target that may be used to render content to.\r\n   * @return {HTMLElement|null} The rendered element.\r\n   */\r\n  renderFrame(frameState, target) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @param {import(\"../Tile.js\").default} tile Tile.\r\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\r\n   */\r\n  loadedTileCallback(tiles, zoom, tile) {\r\n    if (!tiles[zoom]) {\r\n      tiles[zoom] = {};\r\n    }\r\n    tiles[zoom][tile.tileCoord.toString()] = tile;\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Create a function that adds loaded tiles to the tile lookup.\r\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\r\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\r\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\r\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\r\n   * @protected\r\n   */\r\n  createLoadedTileFinder(source, projection, tiles) {\r\n    return (\r\n      /**\r\n       * @param {number} zoom Zoom level.\r\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\r\n       * @return {boolean} The tile range is fully loaded.\r\n       */\r\n      (zoom, tileRange) => {\r\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\r\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\r\n      }\r\n    );\r\n  }\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\r\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\r\n  forEachFeatureAtCoordinate(\r\n    coordinate,\r\n    frameState,\r\n    hitTolerance,\r\n    callback,\r\n    matches,\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @return {LayerType} Layer.\r\n   */\r\n  getLayer() {\r\n    return this.layer_;\r\n  }\r\n\r\n  /**\r\n   * Perform action necessary to get the layer rendered after new fonts have loaded\r\n   * @abstract\r\n   */\r\n  handleFontsChanged() {}\r\n\r\n  /**\r\n   * Handle changes in image state.\r\n   * @param {import(\"../events/Event.js\").default} event Image change event.\r\n   * @private\r\n   */\r\n  handleImageChange_(event) {\r\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\r\n    if (\r\n      image.getState() === ImageState.LOADED ||\r\n      image.getState() === ImageState.ERROR\r\n    ) {\r\n      this.renderIfReadyAndVisible();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load the image if not already loaded, and register the image change\r\n   * listener if needed.\r\n   * @param {import(\"../Image.js\").default} image Image.\r\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\r\n   * @protected\r\n   */\r\n  loadImage(image) {\r\n    let imageState = image.getState();\r\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\r\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\r\n    }\r\n    if (imageState == ImageState.IDLE) {\r\n      image.load();\r\n      imageState = image.getState();\r\n    }\r\n    return imageState == ImageState.LOADED;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  renderIfReadyAndVisible() {\r\n    const layer = this.getLayer();\r\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\r\n      layer.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  renderDeferred(frameState) {}\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  disposeInternal() {\r\n    delete this.layer_;\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default LayerRenderer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}