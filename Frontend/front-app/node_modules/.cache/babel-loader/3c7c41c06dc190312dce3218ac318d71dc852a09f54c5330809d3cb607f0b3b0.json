{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/render/canvas/Executor\r\n */\nimport CanvasInstruction from './Instruction.js';\nimport ZIndexContext from '../canvas/ZIndexContext.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextAlign, defaultTextBaseline, drawImageOrLabel, getTextDimensions, measureAndCacheTextWidth } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n\n/**\r\n * @typedef {Object} BBox\r\n * @property {number} minX Minimal x.\r\n * @property {number} minY Minimal y.\r\n * @property {number} maxX Maximal x.\r\n * @property {number} maxY Maximal y\r\n * @property {*} value Value.\r\n */\n\n/**\r\n * @typedef {Object} ImageOrLabelDimensions\r\n * @property {number} drawImageX DrawImageX.\r\n * @property {number} drawImageY DrawImageY.\r\n * @property {number} drawImageW DrawImageW.\r\n * @property {number} drawImageH DrawImageH.\r\n * @property {number} originX OriginX.\r\n * @property {number} originY OriginY.\r\n * @property {Array<number>} scale Scale.\r\n * @property {BBox} declutterBox DeclutterBox.\r\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\r\n */\n\n/**\r\n * @typedef {{0: CanvasRenderingContext2D, 1: import('../../size.js').Size, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\r\n */\n\n/**\r\n * @template T\r\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, import(\"../../style/Style.js\").DeclutterMode): T} FeatureCallback\r\n */\n\n/**\r\n * @type {import(\"../../extent.js\").Extent}\r\n */\nconst tmpExtent = createEmpty();\n\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p4 = [];\n\n/**\r\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\r\n * @return {BBox} Declutter bbox.\r\n */\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\nconst rtlRegEx = new RegExp( /* eslint-disable prettier/prettier */\n'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'\n/* eslint-enable prettier/prettier */);\n\n/**\r\n * @param {string} text Text.\r\n * @param {CanvasTextAlign} align Alignment.\r\n * @return {number} Text alignment.\r\n */\nfunction horizontalTextAlign(text, align) {\n  if (align === 'start') {\n    align = rtlRegEx.test(text) ? 'right' : 'left';\n  } else if (align === 'end') {\n    align = rtlRegEx.test(text) ? 'left' : 'right';\n  }\n  return TEXT_ALIGN[align];\n}\n\n/**\r\n * @param {Array<string>} acc Accumulator.\r\n * @param {string} line Line of text.\r\n * @param {number} i Index\r\n * @return {Array<string>} Accumulator.\r\n */\nfunction createTextChunks(acc, line, i) {\n  if (i > 0) {\n    acc.push('\\n', '');\n  }\n  acc.push(line, '');\n  return acc;\n}\nclass Executor {\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {boolean} overlaps The replay can have overlapping geometries.\r\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions.\r\n   * @param {boolean} [deferredRendering] Enable deferred rendering.\r\n   */\n  constructor(resolution, pixelRatio, overlaps, instructions, deferredRendering) {\n    /**\r\n     * @protected\r\n     * @type {boolean}\r\n     */\n    this.overlaps = overlaps;\n\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\r\n     * @protected\r\n     * @const\r\n     * @type {number}\r\n     */\n    this.resolution = resolution;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.alignAndScaleFill_;\n\n    /**\r\n     * @protected\r\n     * @type {Array<*>}\r\n     */\n    this.instructions = instructions.instructions;\n\n    /**\r\n     * @protected\r\n     * @type {Array<number>}\r\n     */\n    this.coordinates = instructions.coordinates;\n\n    /**\r\n     * @private\r\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\r\n     */\n    this.coordinateCache_ = {};\n\n    /**\r\n     * @private\r\n     * @type {!import(\"../../transform.js\").Transform}\r\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\r\n     * @protected\r\n     * @type {Array<*>}\r\n     */\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\n    this.viewRotation_ = 0;\n\n    /**\r\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\r\n     */\n    this.fillStates = instructions.fillStates || {};\n\n    /**\r\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\r\n     */\n    this.strokeStates = instructions.strokeStates || {};\n\n    /**\r\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\r\n     */\n    this.textStates = instructions.textStates || {};\n\n    /**\r\n     * @private\r\n     * @type {Object<string, Object<string, number>>}\r\n     */\n    this.widths_ = {};\n\n    /**\r\n     * @private\r\n     * @type {Object<string, import(\"../canvas.js\").Label>}\r\n     */\n    this.labels_ = {};\n\n    /**\r\n     * @private\r\n     * @type {import(\"../canvas/ZIndexContext.js\").default}\r\n     */\n    this.zIndexContext_ = deferredRendering ? new ZIndexContext() : null;\n  }\n\n  /**\r\n   * @return {ZIndexContext} ZIndex context.\r\n   */\n  getZIndexContext() {\n    return this.zIndexContext_;\n  }\n\n  /**\r\n   * @param {string|Array<string>} text Text.\r\n   * @param {string} textKey Text style key.\r\n   * @param {string} fillKey Fill style key.\r\n   * @param {string} strokeKey Stroke style key.\r\n   * @return {import(\"../canvas.js\").Label} Label.\r\n   */\n  createLabel(text, textKey, fillKey, strokeKey) {\n    const key = text + textKey + fillKey + strokeKey;\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    const fillState = fillKey ? this.fillStates[fillKey] : null;\n    const textState = this.textStates[textKey];\n    const pixelRatio = this.pixelRatio;\n    const scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    const textIsArray = Array.isArray(text);\n    const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n    const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    const chunks = textIsArray ? text : text.split('\\n').reduce(createTextChunks, []);\n    const {\n      width,\n      height,\n      widths,\n      heights,\n      lineWidths\n    } = getTextDimensions(textState, chunks);\n    const renderWidth = width + strokeWidth;\n    const contextInstructions = [];\n    // make canvas 2 pixels wider to account for italic text width measurement errors\n    const w = (renderWidth + 2) * scale[0];\n    const h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n    const label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\n      contextInstructions.push('setLineDash', [strokeState.lineDash]);\n      contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n    }\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    const leftRight = 0.5 - align;\n    let x = align * renderWidth + leftRight * strokeWidth;\n    const strokeInstructions = [];\n    const fillInstructions = [];\n    let lineHeight = 0;\n    let lineOffset = 0;\n    let widthHeightIndex = 0;\n    let lineWidthIndex = 0;\n    let previousFont;\n    for (let i = 0, ii = chunks.length; i < ii; i += 2) {\n      const text = chunks[i];\n      if (text === '\\n') {\n        lineOffset += lineHeight;\n        lineHeight = 0;\n        x = align * renderWidth + leftRight * strokeWidth;\n        ++lineWidthIndex;\n        continue;\n      }\n      const font = chunks[i + 1] || textState.font;\n      if (font !== previousFont) {\n        if (strokeKey) {\n          strokeInstructions.push('font', font);\n        }\n        if (fillKey) {\n          fillInstructions.push('font', font);\n        }\n        previousFont = font;\n      }\n      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\n      const fillStrokeArgs = [text, x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]), 0.5 * (strokeWidth + lineHeight) + lineOffset];\n      x += widths[widthHeightIndex];\n      if (strokeKey) {\n        strokeInstructions.push('strokeText', fillStrokeArgs);\n      }\n      if (fillKey) {\n        fillInstructions.push('fillText', fillStrokeArgs);\n      }\n      ++widthHeightIndex;\n    }\n    Array.prototype.push.apply(contextInstructions, strokeInstructions);\n    Array.prototype.push.apply(contextInstructions, fillInstructions);\n    this.labels_[key] = label;\n    return label;\n  }\n\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\r\n   * @param {Array<*>} fillInstruction Fill instruction.\r\n   * @param {Array<*>} strokeInstruction Stroke instruction.\r\n   */\n  replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignAndScaleFill_ = /** @type {number} */fillInstruction[2];\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, /** @type {Array<*>} */strokeInstruction);\n      context.stroke();\n    }\n  }\n\n  /**\r\n   * @private\r\n   * @param {number} sheetWidth Width of the sprite sheet.\r\n   * @param {number} sheetHeight Height of the sprite sheet.\r\n   * @param {number} centerX X.\r\n   * @param {number} centerY Y.\r\n   * @param {number} width Width.\r\n   * @param {number} height Height.\r\n   * @param {number} anchorX Anchor X.\r\n   * @param {number} anchorY Anchor Y.\r\n   * @param {number} originX Origin X.\r\n   * @param {number} originY Origin Y.\r\n   * @param {number} rotation Rotation.\r\n   * @param {import(\"../../size.js\").Size} scale Scale.\r\n   * @param {boolean} snapToPixel Snap to pixel.\r\n   * @param {Array<number>} padding Padding.\r\n   * @param {boolean} fillStroke Background fill or stroke.\r\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\r\n   */\n  calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    let x = centerX - anchorX;\n    let y = centerY - anchorY;\n    const w = width + originX > sheetWidth ? sheetWidth - originX : width;\n    const h = height + originY > sheetHeight ? sheetHeight - originY : height;\n    const boxW = padding[3] + w * scale[0] + padding[1];\n    const boxH = padding[0] + h * scale[1] + padding[2];\n    const boxX = x - padding[3];\n    const boxY = y - padding[0];\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n    let transform;\n    if (rotation !== 0) {\n      transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      applyTransform(transform, p1);\n      applyTransform(transform, p2);\n      applyTransform(transform, p3);\n      applyTransform(transform, p4);\n      createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n    }\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    return {\n      drawImageX: x,\n      drawImageY: y,\n      drawImageW: w,\n      drawImageH: h,\n      originX: originX,\n      originY: originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature\n      },\n      canvasTransform: transform,\n      scale: scale\n    };\n  }\n\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.\r\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\r\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\r\n   * @param {number} opacity Opacity.\r\n   * @param {Array<*>} fillInstruction Fill instruction.\r\n   * @param {Array<*>} strokeInstruction Stroke instruction.\r\n   * @return {boolean} The image or label was rendered.\r\n   */\n  replayImageOrLabel_(context, scaledCanvasSize, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n    const fillStroke = !!(fillInstruction || strokeInstruction);\n    const box = dimensions.declutterBox;\n    const strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;\n    const intersects = box.minX - strokePadding <= scaledCanvasSize[0] && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= scaledCanvasSize[1] && box.maxY + strokePadding >= 0;\n    if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */fillInstruction, /** @type {Array<*>} */strokeInstruction);\n      }\n      drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n    }\n    return true;\n  }\n\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   */\n  fill_(context) {\n    const alignAndScale = this.alignAndScaleFill_;\n    if (alignAndScale) {\n      const origin = applyTransform(this.renderedTransform_, [0, 0]);\n      const repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      if (alignAndScale !== 1) {\n        context.scale(alignAndScale, alignAndScale);\n      }\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (alignAndScale) {\n      context.restore();\n    }\n  }\n\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {Array<*>} instruction Instruction.\r\n   */\n  setStrokeStyle_(context, instruction) {\n    context.strokeStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n    context.lineWidth = /** @type {number} */instruction[2];\n    context.lineCap = /** @type {CanvasLineCap} */instruction[3];\n    context.lineJoin = /** @type {CanvasLineJoin} */instruction[4];\n    context.miterLimit = /** @type {number} */instruction[5];\n    context.lineDashOffset = /** @type {number} */instruction[7];\n    context.setLineDash( /** @type {Array<number>} */instruction[6]);\n  }\n\n  /**\r\n   * @private\r\n   * @param {string|Array<string>} text The text to draw.\r\n   * @param {string} textKey The key of the text state.\r\n   * @param {string} strokeKey The key for the stroke state.\r\n   * @param {string} fillKey The key for the fill state.\r\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\r\n   */\n  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {\n    const textState = this.textStates[textKey];\n    const label = this.createLabel(text, textKey, fillKey, strokeKey);\n    const strokeState = this.strokeStates[strokeKey];\n    const pixelRatio = this.pixelRatio;\n    const align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);\n    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    // Remove the 2 pixels we added in createLabel() for the anchor\n    const width = label.width / pixelRatio - 2 * textState.scale[0];\n    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  }\n\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {Array<*>} instructions Instructions array.\r\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\r\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\r\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\r\n   *     features that intersect this extent.\r\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\n  execute_(context, scaledCanvasSize, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {\n    const zIndexContext = this.zIndexContext_;\n    /** @type {Array<number>} */\n    let pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    let i = 0; // instruction index\n    const ii = instructions.length; // end of instructions\n    let d = 0; // data index\n    let dd; // end of per-instruction data\n    let anchorX, anchorY, /** @type {import('../../style/Style.js').DeclutterMode} */\n      declutterMode, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n    let pendingFill = 0;\n    let pendingStroke = 0;\n    let lastFillInstruction = null;\n    let lastStrokeInstruction = null;\n    const coordinateCache = this.coordinateCache_;\n    const viewRotation = this.viewRotation_;\n    const viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    const state = /** @type {import(\"../../render.js\").State} */{\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    };\n\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    let /** @type {import(\"../../Feature.js\").FeatureLike} */feature;\n    let x, y, currentGeometry;\n    while (i < ii) {\n      const instruction = instructions[i];\n      const type = /** @type {import(\"./Instruction.js\").default} */\n      instruction[0];\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").FeatureLike} */\n          instruction[1];\n          currentGeometry = instruction[3];\n          if (!feature.getGeometry()) {\n            i = /** @type {number} */instruction[2];\n          } else if (hitExtent !== undefined && !intersects(hitExtent, currentGeometry.getExtent())) {\n            i = /** @type {number} */instruction[2] + 1;\n          } else {\n            ++i;\n          }\n          if (zIndexContext) {\n            zIndexContext.zIndex = instruction[4];\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */instruction[1];\n          const x1 = pixelCoordinates[d];\n          const y1 = pixelCoordinates[d + 1];\n          const x2 = pixelCoordinates[d + 2];\n          const y2 = pixelCoordinates[d + 3];\n          const dx = x2 - x1;\n          const dy = y2 - y1;\n          const r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */instruction[1];\n          dd = instruction[2];\n          const geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */\n          instruction[3];\n          const renderer = instruction[4];\n          const fn = instruction[5];\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          const coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          if (zIndexContext) {\n            zIndexContext.zIndex = instruction[6];\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n          instruction[3];\n\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */instruction[4];\n          anchorY = /** @type {number} */instruction[5];\n          let height = /** @type {number} */instruction[6];\n          const opacity = /** @type {number} */instruction[7];\n          const originX = /** @type {number} */instruction[8];\n          const originY = /** @type {number} */instruction[9];\n          const rotateWithView = /** @type {boolean} */instruction[10];\n          let rotation = /** @type {number} */instruction[11];\n          const scale = /** @type {import(\"../../size.js\").Size} */\n          instruction[12];\n          let width = /** @type {number} */instruction[13];\n          declutterMode = instruction[14] || 'declutter';\n          const declutterImageWithText = /** @type {{args: import(\"../canvas.js\").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */\n          instruction[15];\n          if (!image && instruction.length >= 20) {\n            // create label images\n            text = /** @type {string} */instruction[19];\n            textKey = /** @type {string} */instruction[20];\n            strokeKey = /** @type {string} */instruction[21];\n            fillKey = /** @type {string} */instruction[22];\n            const labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            const textOffsetX = /** @type {number} */instruction[23];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            const textOffsetY = /** @type {number} */instruction[24];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[6] = height;\n            width = image.width;\n            instruction[13] = width;\n          }\n          let geometryWidths;\n          if (instruction.length > 25) {\n            geometryWidths = /** @type {number} */instruction[25];\n          }\n          let padding, backgroundFill, backgroundStroke;\n          if (instruction.length > 17) {\n            padding = /** @type {Array<number>} */instruction[16];\n            backgroundFill = /** @type {boolean} */instruction[17];\n            backgroundStroke = /** @type {boolean} */instruction[18];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n          let widthIndex = 0;\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n            const dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n            /** @type {ReplayImageOrLabelArgs} */\n            const args = [context, scaledCanvasSize, image, dimensions, opacity, backgroundFill ? ( /** @type {Array<*>} */lastFillInstruction) : null, backgroundStroke ? ( /** @type {Array<*>} */lastStrokeInstruction) : null];\n            if (declutterTree) {\n              let imageArgs, imageDeclutterMode, imageDeclutterBox;\n              if (declutterImageWithText) {\n                const index = dd - d;\n                if (!declutterImageWithText[index]) {\n                  // We now have the image for an image+text combination.\n                  declutterImageWithText[index] = {\n                    args,\n                    declutterMode\n                  };\n                  // Don't render anything for now, wait for the text.\n                  continue;\n                }\n                const imageDeclutter = declutterImageWithText[index];\n                imageArgs = imageDeclutter.args;\n                imageDeclutterMode = imageDeclutter.declutterMode;\n                delete declutterImageWithText[index];\n                imageDeclutterBox = getDeclutterBox(imageArgs);\n              }\n              // We now have image and text for an image+text combination.\n              let renderImage, renderText;\n              if (imageArgs && (imageDeclutterMode !== 'declutter' || !declutterTree.collides(imageDeclutterBox))) {\n                renderImage = true;\n              }\n              if (declutterMode !== 'declutter' || !declutterTree.collides(dimensions.declutterBox)) {\n                renderText = true;\n              }\n              if (imageDeclutterMode === 'declutter' && declutterMode === 'declutter') {\n                const render = renderImage && renderText;\n                renderImage = render;\n                renderText = render;\n              }\n              if (renderImage) {\n                if (imageDeclutterMode !== 'none') {\n                  declutterTree.insert(imageDeclutterBox);\n                }\n                this.replayImageOrLabel_.apply(this, imageArgs);\n              }\n              if (renderText) {\n                if (declutterMode !== 'none') {\n                  declutterTree.insert(dimensions.declutterBox);\n                }\n                this.replayImageOrLabel_.apply(this, args);\n              }\n            } else {\n              this.replayImageOrLabel_.apply(this, args);\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          const begin = /** @type {number} */instruction[1];\n          const end = /** @type {number} */instruction[2];\n          const baseline = /** @type {number} */instruction[3];\n          const overflow = /** @type {number} */instruction[4];\n          fillKey = /** @type {string} */instruction[5];\n          const maxAngle = /** @type {number} */instruction[6];\n          const measurePixelRatio = /** @type {number} */instruction[7];\n          const offsetY = /** @type {number} */instruction[8];\n          strokeKey = /** @type {string} */instruction[9];\n          const strokeWidth = /** @type {number} */instruction[10];\n          text = /** @type {string} */instruction[11];\n          textKey = /** @type {string} */instruction[12];\n          const pixelRatioScale = [( /** @type {number} */instruction[13]), ( /** @type {number} */instruction[13])];\n          declutterMode = instruction[14] || 'declutter';\n          const textState = this.textStates[textKey];\n          const font = textState.font;\n          const textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          let cachedWidths;\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n          if (overflow || textLength <= pathLength) {\n            const textAlign = this.textStates[textKey].textAlign;\n            const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);\n            const parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n            drawChars: if (parts) {\n              /** @type {Array<ReplayImageOrLabelArgs>} */\n              const replayImageOrLabelArgs = [];\n              let c, cc, chars, label, part;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                  if (declutterTree && declutterMode === 'declutter' && declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n                  replayImageOrLabelArgs.push([context, scaledCanvasSize, label, dimensions, 1, null, null]);\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                  if (declutterTree && declutterMode === 'declutter' && declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n                  replayImageOrLabelArgs.push([context, scaledCanvasSize, label, dimensions, 1, null, null]);\n                }\n              }\n              if (declutterTree && declutterMode !== 'none') {\n                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n              }\n              for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);\n              }\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */\n            instruction[1];\n            const result = featureCallback(feature, currentGeometry, declutterMode);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          context.moveTo(x, y);\n          prevX = x + 0.5 | 0;\n          prevY = y + 0.5 | 0;\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignAndScaleFill_ = instruction[2];\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          /** @type {import(\"../../colorlike.js\").ColorLike} */\n          context.fillStyle = instruction[1];\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */instruction);\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          // consume the instruction anyway, to avoid an infinite loop\n          ++i;\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  }\n\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {number} viewRotation View rotation.\r\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\r\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\r\n   */\n  execute(context, scaledCanvasSize, transform, viewRotation, snapToPixel, declutterTree) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, scaledCanvasSize, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);\n  }\n\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {number} viewRotation View rotation.\r\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\r\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\r\n   *     features that intersect this extent.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\n  executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, [context.canvas.width, context.canvas.height], transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);\n  }\n}\nexport default Executor;","map":{"version":3,"names":["CanvasInstruction","ZIndexContext","TEXT_ALIGN","apply","applyTransform","compose","composeTransform","create","createTransform","setFromArray","transformSetFromArray","createEmpty","createOrUpdate","intersects","defaultPadding","defaultTextAlign","defaultTextBaseline","drawImageOrLabel","getTextDimensions","measureAndCacheTextWidth","drawTextOnPath","equals","lineStringLength","transform2D","tmpExtent","p1","p2","p3","p4","getDeclutterBox","replayImageOrLabelArgs","declutterBox","rtlRegEx","RegExp","String","fromCharCode","horizontalTextAlign","text","align","test","createTextChunks","acc","line","i","push","Executor","constructor","resolution","pixelRatio","overlaps","instructions","deferredRendering","alignAndScaleFill_","coordinates","coordinateCache_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","viewRotation_","fillStates","strokeStates","textStates","widths_","labels_","zIndexContext_","getZIndexContext","createLabel","textKey","fillKey","strokeKey","key","strokeState","fillState","textState","scale","textIsArray","Array","isArray","justify","textAlign","strokeWidth","lineWidth","chunks","split","reduce","width","height","widths","heights","lineWidths","renderWidth","contextInstructions","w","h","label","Math","floor","ceil","strokeStyle","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","fillStyle","leftRight","x","strokeInstructions","fillInstructions","lineHeight","lineOffset","widthHeightIndex","lineWidthIndex","previousFont","ii","length","font","max","fillStrokeArgs","prototype","replayTextBackground_","context","fillInstruction","strokeInstruction","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","calculateImageOrLabelDimensions_","sheetWidth","sheetHeight","centerX","centerY","anchorX","anchorY","originX","originY","rotation","snapToPixel","padding","fillStroke","feature","y","boxW","boxH","boxX","boxY","transform","min","round","drawImageX","drawImageY","drawImageW","drawImageH","minX","minY","maxX","maxY","value","canvasTransform","replayImageOrLabel_","scaledCanvasSize","imageOrLabel","dimensions","opacity","box","strokePadding","alignAndScale","origin","repeatSize","save","translate","rotate","fill","restore","instruction","setLineDash","drawLabelWithPointPlacement_","baseline","textBaseline","execute_","featureCallback","hitExtent","declutterTree","zIndexContext","pixelCoordinates","d","dd","declutterMode","prevX","prevY","roundX","roundY","image","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","viewRotationFromTransform","atan2","state","batchSize","currentGeometry","type","BEGIN_GEOMETRY","getGeometry","undefined","getExtent","zIndex","BEGIN_PATH","NaN","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","CUSTOM","geometry","renderer","fn","coords","DRAW_IMAGE","rotateWithView","declutterImageWithText","labelWithAnchor","textOffsetX","textOffsetY","geometryWidths","backgroundFill","backgroundStroke","widthIndex","args","imageArgs","imageDeclutterMode","imageDeclutterBox","index","imageDeclutter","renderImage","renderText","collides","render","insert","DRAW_CHARS","begin","end","overflow","maxAngle","measurePixelRatio","offsetY","pixelRatioScale","textScale","cachedWidths","pathLength","textLength","abs","startM","parts","drawChars","c","cc","chars","part","load","map","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","SET_STROKE_STYLE","STROKE","execute","executeHitDetection","canvas"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/render/canvas/Executor.js"],"sourcesContent":["/**\r\n * @module ol/render/canvas/Executor\r\n */\r\nimport CanvasInstruction from './Instruction.js';\r\nimport ZIndexContext from '../canvas/ZIndexContext.js';\r\nimport {TEXT_ALIGN} from './TextBuilder.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n  setFromArray as transformSetFromArray,\r\n} from '../../transform.js';\r\nimport {createEmpty, createOrUpdate, intersects} from '../../extent.js';\r\nimport {\r\n  defaultPadding,\r\n  defaultTextAlign,\r\n  defaultTextBaseline,\r\n  drawImageOrLabel,\r\n  getTextDimensions,\r\n  measureAndCacheTextWidth,\r\n} from '../canvas.js';\r\nimport {drawTextOnPath} from '../../geom/flat/textpath.js';\r\nimport {equals} from '../../array.js';\r\nimport {lineStringLength} from '../../geom/flat/length.js';\r\nimport {transform2D} from '../../geom/flat/transform.js';\r\n\r\n/**\r\n * @typedef {Object} BBox\r\n * @property {number} minX Minimal x.\r\n * @property {number} minY Minimal y.\r\n * @property {number} maxX Maximal x.\r\n * @property {number} maxY Maximal y\r\n * @property {*} value Value.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ImageOrLabelDimensions\r\n * @property {number} drawImageX DrawImageX.\r\n * @property {number} drawImageY DrawImageY.\r\n * @property {number} drawImageW DrawImageW.\r\n * @property {number} drawImageH DrawImageH.\r\n * @property {number} originX OriginX.\r\n * @property {number} originY OriginY.\r\n * @property {Array<number>} scale Scale.\r\n * @property {BBox} declutterBox DeclutterBox.\r\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\r\n */\r\n\r\n/**\r\n * @typedef {{0: CanvasRenderingContext2D, 1: import('../../size.js').Size, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default, import(\"../../style/Style.js\").DeclutterMode): T} FeatureCallback\r\n */\r\n\r\n/**\r\n * @type {import(\"../../extent.js\").Extent}\r\n */\r\nconst tmpExtent = createEmpty();\r\n\r\n/** @type {import(\"../../coordinate.js\").Coordinate} */\r\nconst p1 = [];\r\n/** @type {import(\"../../coordinate.js\").Coordinate} */\r\nconst p2 = [];\r\n/** @type {import(\"../../coordinate.js\").Coordinate} */\r\nconst p3 = [];\r\n/** @type {import(\"../../coordinate.js\").Coordinate} */\r\nconst p4 = [];\r\n\r\n/**\r\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\r\n * @return {BBox} Declutter bbox.\r\n */\r\nfunction getDeclutterBox(replayImageOrLabelArgs) {\r\n  return replayImageOrLabelArgs[3].declutterBox;\r\n}\r\n\r\nconst rtlRegEx = new RegExp(\r\n  /* eslint-disable prettier/prettier */\r\n  '[' +\r\n    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +\r\n    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +\r\n    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +\r\n    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +\r\n    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +\r\n  ']'\r\n  /* eslint-enable prettier/prettier */\r\n);\r\n\r\n/**\r\n * @param {string} text Text.\r\n * @param {CanvasTextAlign} align Alignment.\r\n * @return {number} Text alignment.\r\n */\r\nfunction horizontalTextAlign(text, align) {\r\n  if (align === 'start') {\r\n    align = rtlRegEx.test(text) ? 'right' : 'left';\r\n  } else if (align === 'end') {\r\n    align = rtlRegEx.test(text) ? 'left' : 'right';\r\n  }\r\n  return TEXT_ALIGN[align];\r\n}\r\n\r\n/**\r\n * @param {Array<string>} acc Accumulator.\r\n * @param {string} line Line of text.\r\n * @param {number} i Index\r\n * @return {Array<string>} Accumulator.\r\n */\r\nfunction createTextChunks(acc, line, i) {\r\n  if (i > 0) {\r\n    acc.push('\\n', '');\r\n  }\r\n  acc.push(line, '');\r\n  return acc;\r\n}\r\n\r\nclass Executor {\r\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {boolean} overlaps The replay can have overlapping geometries.\r\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions.\r\n   * @param {boolean} [deferredRendering] Enable deferred rendering.\r\n   */\r\n  constructor(\r\n    resolution,\r\n    pixelRatio,\r\n    overlaps,\r\n    instructions,\r\n    deferredRendering,\r\n  ) {\r\n    /**\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.overlaps = overlaps;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio = pixelRatio;\r\n\r\n    /**\r\n     * @protected\r\n     * @const\r\n     * @type {number}\r\n     */\r\n    this.resolution = resolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.alignAndScaleFill_;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {Array<*>}\r\n     */\r\n    this.instructions = instructions.instructions;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {Array<number>}\r\n     */\r\n    this.coordinates = instructions.coordinates;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\r\n     */\r\n    this.coordinateCache_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"../../transform.js\").Transform}\r\n     */\r\n    this.renderedTransform_ = createTransform();\r\n\r\n    /**\r\n     * @protected\r\n     * @type {Array<*>}\r\n     */\r\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.pixelCoordinates_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.viewRotation_ = 0;\r\n\r\n    /**\r\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\r\n     */\r\n    this.fillStates = instructions.fillStates || {};\r\n\r\n    /**\r\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\r\n     */\r\n    this.strokeStates = instructions.strokeStates || {};\r\n\r\n    /**\r\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\r\n     */\r\n    this.textStates = instructions.textStates || {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object<string, number>>}\r\n     */\r\n    this.widths_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, import(\"../canvas.js\").Label>}\r\n     */\r\n    this.labels_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../canvas/ZIndexContext.js\").default}\r\n     */\r\n    this.zIndexContext_ = deferredRendering ? new ZIndexContext() : null;\r\n  }\r\n\r\n  /**\r\n   * @return {ZIndexContext} ZIndex context.\r\n   */\r\n  getZIndexContext() {\r\n    return this.zIndexContext_;\r\n  }\r\n\r\n  /**\r\n   * @param {string|Array<string>} text Text.\r\n   * @param {string} textKey Text style key.\r\n   * @param {string} fillKey Fill style key.\r\n   * @param {string} strokeKey Stroke style key.\r\n   * @return {import(\"../canvas.js\").Label} Label.\r\n   */\r\n  createLabel(text, textKey, fillKey, strokeKey) {\r\n    const key = text + textKey + fillKey + strokeKey;\r\n    if (this.labels_[key]) {\r\n      return this.labels_[key];\r\n    }\r\n    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\r\n    const fillState = fillKey ? this.fillStates[fillKey] : null;\r\n    const textState = this.textStates[textKey];\r\n    const pixelRatio = this.pixelRatio;\r\n    const scale = [\r\n      textState.scale[0] * pixelRatio,\r\n      textState.scale[1] * pixelRatio,\r\n    ];\r\n    const textIsArray = Array.isArray(text);\r\n    const align = textState.justify\r\n      ? TEXT_ALIGN[textState.justify]\r\n      : horizontalTextAlign(\r\n          Array.isArray(text) ? text[0] : text,\r\n          textState.textAlign || defaultTextAlign,\r\n        );\r\n    const strokeWidth =\r\n      strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\r\n\r\n    const chunks = textIsArray\r\n      ? text\r\n      : text.split('\\n').reduce(createTextChunks, []);\r\n\r\n    const {width, height, widths, heights, lineWidths} = getTextDimensions(\r\n      textState,\r\n      chunks,\r\n    );\r\n    const renderWidth = width + strokeWidth;\r\n    const contextInstructions = [];\r\n    // make canvas 2 pixels wider to account for italic text width measurement errors\r\n    const w = (renderWidth + 2) * scale[0];\r\n    const h = (height + strokeWidth) * scale[1];\r\n    /** @type {import(\"../canvas.js\").Label} */\r\n    const label = {\r\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\r\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\r\n      contextInstructions: contextInstructions,\r\n    };\r\n    if (scale[0] != 1 || scale[1] != 1) {\r\n      contextInstructions.push('scale', scale);\r\n    }\r\n    if (strokeKey) {\r\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\r\n      contextInstructions.push('lineWidth', strokeWidth);\r\n      contextInstructions.push('lineCap', strokeState.lineCap);\r\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\r\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\r\n      contextInstructions.push('setLineDash', [strokeState.lineDash]);\r\n      contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\r\n    }\r\n    if (fillKey) {\r\n      contextInstructions.push('fillStyle', fillState.fillStyle);\r\n    }\r\n    contextInstructions.push('textBaseline', 'middle');\r\n    contextInstructions.push('textAlign', 'center');\r\n    const leftRight = 0.5 - align;\r\n    let x = align * renderWidth + leftRight * strokeWidth;\r\n    const strokeInstructions = [];\r\n    const fillInstructions = [];\r\n    let lineHeight = 0;\r\n    let lineOffset = 0;\r\n    let widthHeightIndex = 0;\r\n    let lineWidthIndex = 0;\r\n    let previousFont;\r\n    for (let i = 0, ii = chunks.length; i < ii; i += 2) {\r\n      const text = chunks[i];\r\n      if (text === '\\n') {\r\n        lineOffset += lineHeight;\r\n        lineHeight = 0;\r\n        x = align * renderWidth + leftRight * strokeWidth;\r\n        ++lineWidthIndex;\r\n        continue;\r\n      }\r\n      const font = chunks[i + 1] || textState.font;\r\n      if (font !== previousFont) {\r\n        if (strokeKey) {\r\n          strokeInstructions.push('font', font);\r\n        }\r\n        if (fillKey) {\r\n          fillInstructions.push('font', font);\r\n        }\r\n        previousFont = font;\r\n      }\r\n      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);\r\n      const fillStrokeArgs = [\r\n        text,\r\n        x +\r\n          leftRight * widths[widthHeightIndex] +\r\n          align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),\r\n        0.5 * (strokeWidth + lineHeight) + lineOffset,\r\n      ];\r\n      x += widths[widthHeightIndex];\r\n      if (strokeKey) {\r\n        strokeInstructions.push('strokeText', fillStrokeArgs);\r\n      }\r\n      if (fillKey) {\r\n        fillInstructions.push('fillText', fillStrokeArgs);\r\n      }\r\n      ++widthHeightIndex;\r\n    }\r\n    Array.prototype.push.apply(contextInstructions, strokeInstructions);\r\n    Array.prototype.push.apply(contextInstructions, fillInstructions);\r\n    this.labels_[key] = label;\r\n    return label;\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\r\n   * @param {Array<*>} fillInstruction Fill instruction.\r\n   * @param {Array<*>} strokeInstruction Stroke instruction.\r\n   */\r\n  replayTextBackground_(\r\n    context,\r\n    p1,\r\n    p2,\r\n    p3,\r\n    p4,\r\n    fillInstruction,\r\n    strokeInstruction,\r\n  ) {\r\n    context.beginPath();\r\n    context.moveTo.apply(context, p1);\r\n    context.lineTo.apply(context, p2);\r\n    context.lineTo.apply(context, p3);\r\n    context.lineTo.apply(context, p4);\r\n    context.lineTo.apply(context, p1);\r\n    if (fillInstruction) {\r\n      this.alignAndScaleFill_ = /** @type {number} */ (fillInstruction[2]);\r\n      this.fill_(context);\r\n    }\r\n    if (strokeInstruction) {\r\n      this.setStrokeStyle_(\r\n        context,\r\n        /** @type {Array<*>} */ (strokeInstruction),\r\n      );\r\n      context.stroke();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} sheetWidth Width of the sprite sheet.\r\n   * @param {number} sheetHeight Height of the sprite sheet.\r\n   * @param {number} centerX X.\r\n   * @param {number} centerY Y.\r\n   * @param {number} width Width.\r\n   * @param {number} height Height.\r\n   * @param {number} anchorX Anchor X.\r\n   * @param {number} anchorY Anchor Y.\r\n   * @param {number} originX Origin X.\r\n   * @param {number} originY Origin Y.\r\n   * @param {number} rotation Rotation.\r\n   * @param {import(\"../../size.js\").Size} scale Scale.\r\n   * @param {boolean} snapToPixel Snap to pixel.\r\n   * @param {Array<number>} padding Padding.\r\n   * @param {boolean} fillStroke Background fill or stroke.\r\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\r\n   */\r\n  calculateImageOrLabelDimensions_(\r\n    sheetWidth,\r\n    sheetHeight,\r\n    centerX,\r\n    centerY,\r\n    width,\r\n    height,\r\n    anchorX,\r\n    anchorY,\r\n    originX,\r\n    originY,\r\n    rotation,\r\n    scale,\r\n    snapToPixel,\r\n    padding,\r\n    fillStroke,\r\n    feature,\r\n  ) {\r\n    anchorX *= scale[0];\r\n    anchorY *= scale[1];\r\n    let x = centerX - anchorX;\r\n    let y = centerY - anchorY;\r\n\r\n    const w = width + originX > sheetWidth ? sheetWidth - originX : width;\r\n    const h = height + originY > sheetHeight ? sheetHeight - originY : height;\r\n    const boxW = padding[3] + w * scale[0] + padding[1];\r\n    const boxH = padding[0] + h * scale[1] + padding[2];\r\n    const boxX = x - padding[3];\r\n    const boxY = y - padding[0];\r\n\r\n    if (fillStroke || rotation !== 0) {\r\n      p1[0] = boxX;\r\n      p4[0] = boxX;\r\n      p1[1] = boxY;\r\n      p2[1] = boxY;\r\n      p2[0] = boxX + boxW;\r\n      p3[0] = p2[0];\r\n      p3[1] = boxY + boxH;\r\n      p4[1] = p3[1];\r\n    }\r\n\r\n    let transform;\r\n    if (rotation !== 0) {\r\n      transform = composeTransform(\r\n        createTransform(),\r\n        centerX,\r\n        centerY,\r\n        1,\r\n        1,\r\n        rotation,\r\n        -centerX,\r\n        -centerY,\r\n      );\r\n\r\n      applyTransform(transform, p1);\r\n      applyTransform(transform, p2);\r\n      applyTransform(transform, p3);\r\n      applyTransform(transform, p4);\r\n      createOrUpdate(\r\n        Math.min(p1[0], p2[0], p3[0], p4[0]),\r\n        Math.min(p1[1], p2[1], p3[1], p4[1]),\r\n        Math.max(p1[0], p2[0], p3[0], p4[0]),\r\n        Math.max(p1[1], p2[1], p3[1], p4[1]),\r\n        tmpExtent,\r\n      );\r\n    } else {\r\n      createOrUpdate(\r\n        Math.min(boxX, boxX + boxW),\r\n        Math.min(boxY, boxY + boxH),\r\n        Math.max(boxX, boxX + boxW),\r\n        Math.max(boxY, boxY + boxH),\r\n        tmpExtent,\r\n      );\r\n    }\r\n    if (snapToPixel) {\r\n      x = Math.round(x);\r\n      y = Math.round(y);\r\n    }\r\n    return {\r\n      drawImageX: x,\r\n      drawImageY: y,\r\n      drawImageW: w,\r\n      drawImageH: h,\r\n      originX: originX,\r\n      originY: originY,\r\n      declutterBox: {\r\n        minX: tmpExtent[0],\r\n        minY: tmpExtent[1],\r\n        maxX: tmpExtent[2],\r\n        maxY: tmpExtent[3],\r\n        value: feature,\r\n      },\r\n      canvasTransform: transform,\r\n      scale: scale,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.\r\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\r\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\r\n   * @param {number} opacity Opacity.\r\n   * @param {Array<*>} fillInstruction Fill instruction.\r\n   * @param {Array<*>} strokeInstruction Stroke instruction.\r\n   * @return {boolean} The image or label was rendered.\r\n   */\r\n  replayImageOrLabel_(\r\n    context,\r\n    scaledCanvasSize,\r\n    imageOrLabel,\r\n    dimensions,\r\n    opacity,\r\n    fillInstruction,\r\n    strokeInstruction,\r\n  ) {\r\n    const fillStroke = !!(fillInstruction || strokeInstruction);\r\n\r\n    const box = dimensions.declutterBox;\r\n    const strokePadding = strokeInstruction\r\n      ? (strokeInstruction[2] * dimensions.scale[0]) / 2\r\n      : 0;\r\n    const intersects =\r\n      box.minX - strokePadding <= scaledCanvasSize[0] &&\r\n      box.maxX + strokePadding >= 0 &&\r\n      box.minY - strokePadding <= scaledCanvasSize[1] &&\r\n      box.maxY + strokePadding >= 0;\r\n\r\n    if (intersects) {\r\n      if (fillStroke) {\r\n        this.replayTextBackground_(\r\n          context,\r\n          p1,\r\n          p2,\r\n          p3,\r\n          p4,\r\n          /** @type {Array<*>} */ (fillInstruction),\r\n          /** @type {Array<*>} */ (strokeInstruction),\r\n        );\r\n      }\r\n      drawImageOrLabel(\r\n        context,\r\n        dimensions.canvasTransform,\r\n        opacity,\r\n        imageOrLabel,\r\n        dimensions.originX,\r\n        dimensions.originY,\r\n        dimensions.drawImageW,\r\n        dimensions.drawImageH,\r\n        dimensions.drawImageX,\r\n        dimensions.drawImageY,\r\n        dimensions.scale,\r\n      );\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   */\r\n  fill_(context) {\r\n    const alignAndScale = this.alignAndScaleFill_;\r\n    if (alignAndScale) {\r\n      const origin = applyTransform(this.renderedTransform_, [0, 0]);\r\n      const repeatSize = 512 * this.pixelRatio;\r\n      context.save();\r\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\r\n      if (alignAndScale !== 1) {\r\n        context.scale(alignAndScale, alignAndScale);\r\n      }\r\n      context.rotate(this.viewRotation_);\r\n    }\r\n    context.fill();\r\n    if (alignAndScale) {\r\n      context.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {Array<*>} instruction Instruction.\r\n   */\r\n  setStrokeStyle_(context, instruction) {\r\n    context.strokeStyle =\r\n      /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\r\n    context.lineWidth = /** @type {number} */ (instruction[2]);\r\n    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\r\n    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\r\n    context.miterLimit = /** @type {number} */ (instruction[5]);\r\n    context.lineDashOffset = /** @type {number} */ (instruction[7]);\r\n    context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {string|Array<string>} text The text to draw.\r\n   * @param {string} textKey The key of the text state.\r\n   * @param {string} strokeKey The key for the stroke state.\r\n   * @param {string} fillKey The key for the fill state.\r\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\r\n   */\r\n  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {\r\n    const textState = this.textStates[textKey];\r\n\r\n    const label = this.createLabel(text, textKey, fillKey, strokeKey);\r\n\r\n    const strokeState = this.strokeStates[strokeKey];\r\n    const pixelRatio = this.pixelRatio;\r\n    const align = horizontalTextAlign(\r\n      Array.isArray(text) ? text[0] : text,\r\n      textState.textAlign || defaultTextAlign,\r\n    );\r\n    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\r\n    const strokeWidth =\r\n      strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\r\n\r\n    // Remove the 2 pixels we added in createLabel() for the anchor\r\n    const width = label.width / pixelRatio - 2 * textState.scale[0];\r\n    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\r\n    const anchorY =\r\n      (baseline * label.height) / pixelRatio +\r\n      2 * (0.5 - baseline) * strokeWidth;\r\n\r\n    return {\r\n      label: label,\r\n      anchorX: anchorX,\r\n      anchorY: anchorY,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {Array<*>} instructions Instructions array.\r\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\r\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\r\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\r\n   *     features that intersect this extent.\r\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\r\n  execute_(\r\n    context,\r\n    scaledCanvasSize,\r\n    transform,\r\n    instructions,\r\n    snapToPixel,\r\n    featureCallback,\r\n    hitExtent,\r\n    declutterTree,\r\n  ) {\r\n    const zIndexContext = this.zIndexContext_;\r\n    /** @type {Array<number>} */\r\n    let pixelCoordinates;\r\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\r\n      pixelCoordinates = this.pixelCoordinates_;\r\n    } else {\r\n      if (!this.pixelCoordinates_) {\r\n        this.pixelCoordinates_ = [];\r\n      }\r\n      pixelCoordinates = transform2D(\r\n        this.coordinates,\r\n        0,\r\n        this.coordinates.length,\r\n        2,\r\n        transform,\r\n        this.pixelCoordinates_,\r\n      );\r\n      transformSetFromArray(this.renderedTransform_, transform);\r\n    }\r\n    let i = 0; // instruction index\r\n    const ii = instructions.length; // end of instructions\r\n    let d = 0; // data index\r\n    let dd; // end of per-instruction data\r\n    let anchorX,\r\n      anchorY,\r\n      /** @type {import('../../style/Style.js').DeclutterMode} */\r\n      declutterMode,\r\n      prevX,\r\n      prevY,\r\n      roundX,\r\n      roundY,\r\n      image,\r\n      text,\r\n      textKey,\r\n      strokeKey,\r\n      fillKey;\r\n    let pendingFill = 0;\r\n    let pendingStroke = 0;\r\n    let lastFillInstruction = null;\r\n    let lastStrokeInstruction = null;\r\n    const coordinateCache = this.coordinateCache_;\r\n    const viewRotation = this.viewRotation_;\r\n    const viewRotationFromTransform =\r\n      Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\r\n\r\n    const state = /** @type {import(\"../../render.js\").State} */ ({\r\n      context: context,\r\n      pixelRatio: this.pixelRatio,\r\n      resolution: this.resolution,\r\n      rotation: viewRotation,\r\n    });\r\n\r\n    // When the batch size gets too big, performance decreases. 200 is a good\r\n    // balance between batch size and number of fill/stroke instructions.\r\n    const batchSize =\r\n      this.instructions != instructions || this.overlaps ? 0 : 200;\r\n    let /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\r\n    let x, y, currentGeometry;\r\n    while (i < ii) {\r\n      const instruction = instructions[i];\r\n      const type = /** @type {import(\"./Instruction.js\").default} */ (\r\n        instruction[0]\r\n      );\r\n      switch (type) {\r\n        case CanvasInstruction.BEGIN_GEOMETRY:\r\n          feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (\r\n            instruction[1]\r\n          );\r\n          currentGeometry = instruction[3];\r\n          if (!feature.getGeometry()) {\r\n            i = /** @type {number} */ (instruction[2]);\r\n          } else if (\r\n            hitExtent !== undefined &&\r\n            !intersects(hitExtent, currentGeometry.getExtent())\r\n          ) {\r\n            i = /** @type {number} */ (instruction[2]) + 1;\r\n          } else {\r\n            ++i;\r\n          }\r\n          if (zIndexContext) {\r\n            zIndexContext.zIndex = instruction[4];\r\n          }\r\n          break;\r\n        case CanvasInstruction.BEGIN_PATH:\r\n          if (pendingFill > batchSize) {\r\n            this.fill_(context);\r\n            pendingFill = 0;\r\n          }\r\n          if (pendingStroke > batchSize) {\r\n            context.stroke();\r\n            pendingStroke = 0;\r\n          }\r\n          if (!pendingFill && !pendingStroke) {\r\n            context.beginPath();\r\n            prevX = NaN;\r\n            prevY = NaN;\r\n          }\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.CIRCLE:\r\n          d = /** @type {number} */ (instruction[1]);\r\n          const x1 = pixelCoordinates[d];\r\n          const y1 = pixelCoordinates[d + 1];\r\n          const x2 = pixelCoordinates[d + 2];\r\n          const y2 = pixelCoordinates[d + 3];\r\n          const dx = x2 - x1;\r\n          const dy = y2 - y1;\r\n          const r = Math.sqrt(dx * dx + dy * dy);\r\n          context.moveTo(x1 + r, y1);\r\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.CLOSE_PATH:\r\n          context.closePath();\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.CUSTOM:\r\n          d = /** @type {number} */ (instruction[1]);\r\n          dd = instruction[2];\r\n          const geometry =\r\n            /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (\r\n              instruction[3]\r\n            );\r\n          const renderer = instruction[4];\r\n          const fn = instruction[5];\r\n          state.geometry = geometry;\r\n          state.feature = feature;\r\n          if (!(i in coordinateCache)) {\r\n            coordinateCache[i] = [];\r\n          }\r\n          const coords = coordinateCache[i];\r\n          if (fn) {\r\n            fn(pixelCoordinates, d, dd, 2, coords);\r\n          } else {\r\n            coords[0] = pixelCoordinates[d];\r\n            coords[1] = pixelCoordinates[d + 1];\r\n            coords.length = 2;\r\n          }\r\n          if (zIndexContext) {\r\n            zIndexContext.zIndex = instruction[6];\r\n          }\r\n          renderer(coords, state);\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.DRAW_IMAGE:\r\n          d = /** @type {number} */ (instruction[1]);\r\n          dd = /** @type {number} */ (instruction[2]);\r\n          image =\r\n            /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (\r\n              instruction[3]\r\n            );\r\n\r\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\r\n          anchorX = /** @type {number} */ (instruction[4]);\r\n          anchorY = /** @type {number} */ (instruction[5]);\r\n          let height = /** @type {number} */ (instruction[6]);\r\n          const opacity = /** @type {number} */ (instruction[7]);\r\n          const originX = /** @type {number} */ (instruction[8]);\r\n          const originY = /** @type {number} */ (instruction[9]);\r\n          const rotateWithView = /** @type {boolean} */ (instruction[10]);\r\n          let rotation = /** @type {number} */ (instruction[11]);\r\n          const scale = /** @type {import(\"../../size.js\").Size} */ (\r\n            instruction[12]\r\n          );\r\n          let width = /** @type {number} */ (instruction[13]);\r\n          declutterMode = instruction[14] || 'declutter';\r\n          const declutterImageWithText =\r\n            /** @type {{args: import(\"../canvas.js\").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */ (\r\n              instruction[15]\r\n            );\r\n\r\n          if (!image && instruction.length >= 20) {\r\n            // create label images\r\n            text = /** @type {string} */ (instruction[19]);\r\n            textKey = /** @type {string} */ (instruction[20]);\r\n            strokeKey = /** @type {string} */ (instruction[21]);\r\n            fillKey = /** @type {string} */ (instruction[22]);\r\n            const labelWithAnchor = this.drawLabelWithPointPlacement_(\r\n              text,\r\n              textKey,\r\n              strokeKey,\r\n              fillKey,\r\n            );\r\n            image = labelWithAnchor.label;\r\n            instruction[3] = image;\r\n            const textOffsetX = /** @type {number} */ (instruction[23]);\r\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\r\n            instruction[4] = anchorX;\r\n            const textOffsetY = /** @type {number} */ (instruction[24]);\r\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\r\n            instruction[5] = anchorY;\r\n            height = image.height;\r\n            instruction[6] = height;\r\n            width = image.width;\r\n            instruction[13] = width;\r\n          }\r\n\r\n          let geometryWidths;\r\n          if (instruction.length > 25) {\r\n            geometryWidths = /** @type {number} */ (instruction[25]);\r\n          }\r\n\r\n          let padding, backgroundFill, backgroundStroke;\r\n          if (instruction.length > 17) {\r\n            padding = /** @type {Array<number>} */ (instruction[16]);\r\n            backgroundFill = /** @type {boolean} */ (instruction[17]);\r\n            backgroundStroke = /** @type {boolean} */ (instruction[18]);\r\n          } else {\r\n            padding = defaultPadding;\r\n            backgroundFill = false;\r\n            backgroundStroke = false;\r\n          }\r\n\r\n          if (rotateWithView && viewRotationFromTransform) {\r\n            // Canvas is expected to be rotated to reverse view rotation.\r\n            rotation += viewRotation;\r\n          } else if (!rotateWithView && !viewRotationFromTransform) {\r\n            // Canvas is not rotated, images need to be rotated back to be north-up.\r\n            rotation -= viewRotation;\r\n          }\r\n          let widthIndex = 0;\r\n          for (; d < dd; d += 2) {\r\n            if (\r\n              geometryWidths &&\r\n              geometryWidths[widthIndex++] < width / this.pixelRatio\r\n            ) {\r\n              continue;\r\n            }\r\n            const dimensions = this.calculateImageOrLabelDimensions_(\r\n              image.width,\r\n              image.height,\r\n              pixelCoordinates[d],\r\n              pixelCoordinates[d + 1],\r\n              width,\r\n              height,\r\n              anchorX,\r\n              anchorY,\r\n              originX,\r\n              originY,\r\n              rotation,\r\n              scale,\r\n              snapToPixel,\r\n              padding,\r\n              backgroundFill || backgroundStroke,\r\n              feature,\r\n            );\r\n            /** @type {ReplayImageOrLabelArgs} */\r\n            const args = [\r\n              context,\r\n              scaledCanvasSize,\r\n              image,\r\n              dimensions,\r\n              opacity,\r\n              backgroundFill\r\n                ? /** @type {Array<*>} */ (lastFillInstruction)\r\n                : null,\r\n              backgroundStroke\r\n                ? /** @type {Array<*>} */ (lastStrokeInstruction)\r\n                : null,\r\n            ];\r\n            if (declutterTree) {\r\n              let imageArgs, imageDeclutterMode, imageDeclutterBox;\r\n              if (declutterImageWithText) {\r\n                const index = dd - d;\r\n                if (!declutterImageWithText[index]) {\r\n                  // We now have the image for an image+text combination.\r\n                  declutterImageWithText[index] = {args, declutterMode};\r\n                  // Don't render anything for now, wait for the text.\r\n                  continue;\r\n                }\r\n                const imageDeclutter = declutterImageWithText[index];\r\n                imageArgs = imageDeclutter.args;\r\n                imageDeclutterMode = imageDeclutter.declutterMode;\r\n                delete declutterImageWithText[index];\r\n                imageDeclutterBox = getDeclutterBox(imageArgs);\r\n              }\r\n              // We now have image and text for an image+text combination.\r\n              let renderImage, renderText;\r\n              if (\r\n                imageArgs &&\r\n                (imageDeclutterMode !== 'declutter' ||\r\n                  !declutterTree.collides(imageDeclutterBox))\r\n              ) {\r\n                renderImage = true;\r\n              }\r\n              if (\r\n                declutterMode !== 'declutter' ||\r\n                !declutterTree.collides(dimensions.declutterBox)\r\n              ) {\r\n                renderText = true;\r\n              }\r\n              if (\r\n                imageDeclutterMode === 'declutter' &&\r\n                declutterMode === 'declutter'\r\n              ) {\r\n                const render = renderImage && renderText;\r\n                renderImage = render;\r\n                renderText = render;\r\n              }\r\n              if (renderImage) {\r\n                if (imageDeclutterMode !== 'none') {\r\n                  declutterTree.insert(imageDeclutterBox);\r\n                }\r\n                this.replayImageOrLabel_.apply(this, imageArgs);\r\n              }\r\n              if (renderText) {\r\n                if (declutterMode !== 'none') {\r\n                  declutterTree.insert(dimensions.declutterBox);\r\n                }\r\n                this.replayImageOrLabel_.apply(this, args);\r\n              }\r\n            } else {\r\n              this.replayImageOrLabel_.apply(this, args);\r\n            }\r\n          }\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.DRAW_CHARS:\r\n          const begin = /** @type {number} */ (instruction[1]);\r\n          const end = /** @type {number} */ (instruction[2]);\r\n          const baseline = /** @type {number} */ (instruction[3]);\r\n          const overflow = /** @type {number} */ (instruction[4]);\r\n          fillKey = /** @type {string} */ (instruction[5]);\r\n          const maxAngle = /** @type {number} */ (instruction[6]);\r\n          const measurePixelRatio = /** @type {number} */ (instruction[7]);\r\n          const offsetY = /** @type {number} */ (instruction[8]);\r\n          strokeKey = /** @type {string} */ (instruction[9]);\r\n          const strokeWidth = /** @type {number} */ (instruction[10]);\r\n          text = /** @type {string} */ (instruction[11]);\r\n          textKey = /** @type {string} */ (instruction[12]);\r\n          const pixelRatioScale = [\r\n            /** @type {number} */ (instruction[13]),\r\n            /** @type {number} */ (instruction[13]),\r\n          ];\r\n          declutterMode = instruction[14] || 'declutter';\r\n\r\n          const textState = this.textStates[textKey];\r\n          const font = textState.font;\r\n          const textScale = [\r\n            textState.scale[0] * measurePixelRatio,\r\n            textState.scale[1] * measurePixelRatio,\r\n          ];\r\n\r\n          let cachedWidths;\r\n          if (font in this.widths_) {\r\n            cachedWidths = this.widths_[font];\r\n          } else {\r\n            cachedWidths = {};\r\n            this.widths_[font] = cachedWidths;\r\n          }\r\n\r\n          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\r\n          const textLength =\r\n            Math.abs(textScale[0]) *\r\n            measureAndCacheTextWidth(font, text, cachedWidths);\r\n          if (overflow || textLength <= pathLength) {\r\n            const textAlign = this.textStates[textKey].textAlign;\r\n            const startM =\r\n              (pathLength - textLength) * horizontalTextAlign(text, textAlign);\r\n            const parts = drawTextOnPath(\r\n              pixelCoordinates,\r\n              begin,\r\n              end,\r\n              2,\r\n              text,\r\n              startM,\r\n              maxAngle,\r\n              Math.abs(textScale[0]),\r\n              measureAndCacheTextWidth,\r\n              font,\r\n              cachedWidths,\r\n              viewRotationFromTransform ? 0 : this.viewRotation_,\r\n            );\r\n            drawChars: if (parts) {\r\n              /** @type {Array<ReplayImageOrLabelArgs>} */\r\n              const replayImageOrLabelArgs = [];\r\n              let c, cc, chars, label, part;\r\n              if (strokeKey) {\r\n                for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                  chars = /** @type {string} */ (part[4]);\r\n                  label = this.createLabel(chars, textKey, '', strokeKey);\r\n                  anchorX =\r\n                    /** @type {number} */ (part[2]) +\r\n                    (textScale[0] < 0 ? -strokeWidth : strokeWidth);\r\n                  anchorY =\r\n                    baseline * label.height +\r\n                    ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\r\n                      textScale[0] -\r\n                    offsetY;\r\n                  const dimensions = this.calculateImageOrLabelDimensions_(\r\n                    label.width,\r\n                    label.height,\r\n                    part[0],\r\n                    part[1],\r\n                    label.width,\r\n                    label.height,\r\n                    anchorX,\r\n                    anchorY,\r\n                    0,\r\n                    0,\r\n                    part[3],\r\n                    pixelRatioScale,\r\n                    false,\r\n                    defaultPadding,\r\n                    false,\r\n                    feature,\r\n                  );\r\n                  if (\r\n                    declutterTree &&\r\n                    declutterMode === 'declutter' &&\r\n                    declutterTree.collides(dimensions.declutterBox)\r\n                  ) {\r\n                    break drawChars;\r\n                  }\r\n                  replayImageOrLabelArgs.push([\r\n                    context,\r\n                    scaledCanvasSize,\r\n                    label,\r\n                    dimensions,\r\n                    1,\r\n                    null,\r\n                    null,\r\n                  ]);\r\n                }\r\n              }\r\n              if (fillKey) {\r\n                for (c = 0, cc = parts.length; c < cc; ++c) {\r\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\r\n                  chars = /** @type {string} */ (part[4]);\r\n                  label = this.createLabel(chars, textKey, fillKey, '');\r\n                  anchorX = /** @type {number} */ (part[2]);\r\n                  anchorY = baseline * label.height - offsetY;\r\n                  const dimensions = this.calculateImageOrLabelDimensions_(\r\n                    label.width,\r\n                    label.height,\r\n                    part[0],\r\n                    part[1],\r\n                    label.width,\r\n                    label.height,\r\n                    anchorX,\r\n                    anchorY,\r\n                    0,\r\n                    0,\r\n                    part[3],\r\n                    pixelRatioScale,\r\n                    false,\r\n                    defaultPadding,\r\n                    false,\r\n                    feature,\r\n                  );\r\n                  if (\r\n                    declutterTree &&\r\n                    declutterMode === 'declutter' &&\r\n                    declutterTree.collides(dimensions.declutterBox)\r\n                  ) {\r\n                    break drawChars;\r\n                  }\r\n                  replayImageOrLabelArgs.push([\r\n                    context,\r\n                    scaledCanvasSize,\r\n                    label,\r\n                    dimensions,\r\n                    1,\r\n                    null,\r\n                    null,\r\n                  ]);\r\n                }\r\n              }\r\n              if (declutterTree && declutterMode !== 'none') {\r\n                declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\r\n              }\r\n              for (let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i) {\r\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);\r\n              }\r\n            }\r\n          }\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.END_GEOMETRY:\r\n          if (featureCallback !== undefined) {\r\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (\r\n              instruction[1]\r\n            );\r\n            const result = featureCallback(\r\n              feature,\r\n              currentGeometry,\r\n              declutterMode,\r\n            );\r\n            if (result) {\r\n              return result;\r\n            }\r\n          }\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.FILL:\r\n          if (batchSize) {\r\n            pendingFill++;\r\n          } else {\r\n            this.fill_(context);\r\n          }\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.MOVE_TO_LINE_TO:\r\n          d = /** @type {number} */ (instruction[1]);\r\n          dd = /** @type {number} */ (instruction[2]);\r\n          x = pixelCoordinates[d];\r\n          y = pixelCoordinates[d + 1];\r\n          context.moveTo(x, y);\r\n          prevX = (x + 0.5) | 0;\r\n          prevY = (y + 0.5) | 0;\r\n          for (d += 2; d < dd; d += 2) {\r\n            x = pixelCoordinates[d];\r\n            y = pixelCoordinates[d + 1];\r\n            roundX = (x + 0.5) | 0;\r\n            roundY = (y + 0.5) | 0;\r\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\r\n              context.lineTo(x, y);\r\n              prevX = roundX;\r\n              prevY = roundY;\r\n            }\r\n          }\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.SET_FILL_STYLE:\r\n          lastFillInstruction = instruction;\r\n          this.alignAndScaleFill_ = instruction[2];\r\n\r\n          if (pendingFill) {\r\n            this.fill_(context);\r\n            pendingFill = 0;\r\n            if (pendingStroke) {\r\n              context.stroke();\r\n              pendingStroke = 0;\r\n            }\r\n          }\r\n\r\n          /** @type {import(\"../../colorlike.js\").ColorLike} */\r\n          context.fillStyle = instruction[1];\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.SET_STROKE_STYLE:\r\n          lastStrokeInstruction = instruction;\r\n          if (pendingStroke) {\r\n            context.stroke();\r\n            pendingStroke = 0;\r\n          }\r\n          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\r\n          ++i;\r\n          break;\r\n        case CanvasInstruction.STROKE:\r\n          if (batchSize) {\r\n            pendingStroke++;\r\n          } else {\r\n            context.stroke();\r\n          }\r\n          ++i;\r\n          break;\r\n        default: // consume the instruction anyway, to avoid an infinite loop\r\n          ++i;\r\n          break;\r\n      }\r\n    }\r\n    if (pendingFill) {\r\n      this.fill_(context);\r\n    }\r\n    if (pendingStroke) {\r\n      context.stroke();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {number} viewRotation View rotation.\r\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\r\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\r\n   */\r\n  execute(\r\n    context,\r\n    scaledCanvasSize,\r\n    transform,\r\n    viewRotation,\r\n    snapToPixel,\r\n    declutterTree,\r\n  ) {\r\n    this.viewRotation_ = viewRotation;\r\n    this.execute_(\r\n      context,\r\n      scaledCanvasSize,\r\n      transform,\r\n      this.instructions,\r\n      snapToPixel,\r\n      undefined,\r\n      undefined,\r\n      declutterTree,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n   * @param {number} viewRotation View rotation.\r\n   * @param {FeatureCallback<T>} [featureCallback] Feature callback.\r\n   * @param {import(\"../../extent.js\").Extent} [hitExtent] Only check\r\n   *     features that intersect this extent.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\r\n  executeHitDetection(\r\n    context,\r\n    transform,\r\n    viewRotation,\r\n    featureCallback,\r\n    hitExtent,\r\n  ) {\r\n    this.viewRotation_ = viewRotation;\r\n    return this.execute_(\r\n      context,\r\n      [context.canvas.width, context.canvas.height],\r\n      transform,\r\n      this.hitDetectionInstructions,\r\n      true,\r\n      featureCallback,\r\n      hitExtent,\r\n    );\r\n  }\r\n}\r\n\r\nexport default Executor;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}