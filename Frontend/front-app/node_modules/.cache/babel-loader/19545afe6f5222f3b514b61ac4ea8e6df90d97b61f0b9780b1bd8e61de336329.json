{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/events/Target\r\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport { VOID } from '../functions.js';\nimport { clear } from '../obj.js';\n\n/**\r\n * @typedef {EventTarget|Target} EventTargetLike\r\n */\n\n/**\r\n * @classdesc\r\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\r\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\r\n *\r\n * There are two important simplifications compared to the specification:\r\n *\r\n * 1. The handling of `useCapture` in `addEventListener` and\r\n *    `removeEventListener`. There is no real capture model.\r\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\r\n *    There is no event target hierarchy. When a listener calls\r\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\r\n *    more listeners after this one will be called. Same as when the listener\r\n *    returns false.\r\n */\nclass Target extends Disposable {\n  /**\r\n   * @param {*} [target] Default event target for dispatched events.\r\n   */\n  constructor(target) {\n    super();\n\n    /**\r\n     * @private\r\n     * @type {*}\r\n     */\n    this.eventTarget_ = target;\n\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\n    this.pendingRemovals_ = null;\n\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\n    this.dispatching_ = null;\n\n    /**\r\n     * @private\r\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>|null}\r\n     */\n    this.listeners_ = null;\n  }\n\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\n  addEventListener(type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n    const listeners = this.listeners_ || (this.listeners_ = {});\n    const listenersForType = listeners[type] || (listeners[type] = []);\n    if (!listenersForType.includes(listener)) {\n      listenersForType.push(listener);\n    }\n  }\n\n  /**\r\n   * Dispatches an event and calls all listeners listening for events\r\n   * of this type. The event parameter can either be a string or an\r\n   * Object with a `type` property.\r\n   *\r\n   * @param {import(\"./Event.js\").default|string} event Event object.\r\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\r\n   *     event object or if any of the listeners returned false.\r\n   * @api\r\n   */\n  dispatchEvent(event) {\n    const isString = typeof event === 'string';\n    const type = isString ? event : event.type;\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n    const evt = isString ? new Event(event) : ( /** @type {Event} */event);\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\n    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});\n    if (!(type in dispatching)) {\n      dispatching[type] = 0;\n      pendingRemovals[type] = 0;\n    }\n    ++dispatching[type];\n    let propagate;\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      if ('handleEvent' in listeners[i]) {\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */listeners[i].handleEvent(evt);\n      } else {\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */listeners[i].call(this, evt);\n      }\n      if (propagate === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n    if (--dispatching[type] === 0) {\n      let pr = pendingRemovals[type];\n      delete pendingRemovals[type];\n      while (pr--) {\n        this.removeEventListener(type, VOID);\n      }\n      delete dispatching[type];\n    }\n    return propagate;\n  }\n\n  /**\r\n   * Clean up.\r\n   */\n  disposeInternal() {\n    this.listeners_ && clear(this.listeners_);\n  }\n\n  /**\r\n   * Get the listeners for a specified event type. Listeners are returned in the\r\n   * order that they will be called in.\r\n   *\r\n   * @param {string} type Type.\r\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\r\n   */\n  getListeners(type) {\n    return this.listeners_ && this.listeners_[type] || undefined;\n  }\n\n  /**\r\n   * @param {string} [type] Type. If not provided,\r\n   *     `true` will be returned if this event target has any listeners.\r\n   * @return {boolean} Has listeners.\r\n   */\n  hasListener(type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n  }\n\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\n  removeEventListener(type, listener) {\n    if (!this.listeners_) {\n      return;\n    }\n    const listeners = this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n        // make listener a no-op, and remove later in #dispatchEvent()\n        listeners[index] = VOID;\n        ++this.pendingRemovals_[type];\n      } else {\n        listeners.splice(index, 1);\n        if (listeners.length === 0) {\n          delete this.listeners_[type];\n        }\n      }\n    }\n  }\n}\nexport default Target;","map":{"version":3,"names":["Disposable","Event","VOID","clear","Target","constructor","target","eventTarget_","pendingRemovals_","dispatching_","listeners_","addEventListener","type","listener","listeners","listenersForType","includes","push","dispatchEvent","event","isString","evt","dispatching","pendingRemovals","propagate","i","ii","length","handleEvent","call","propagationStopped","pr","removeEventListener","disposeInternal","getListeners","undefined","hasListener","Object","keys","index","indexOf","splice"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/events/Target.js"],"sourcesContent":["/**\r\n * @module ol/events/Target\r\n */\r\nimport Disposable from '../Disposable.js';\r\nimport Event from './Event.js';\r\nimport {VOID} from '../functions.js';\r\nimport {clear} from '../obj.js';\r\n\r\n/**\r\n * @typedef {EventTarget|Target} EventTargetLike\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\r\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\r\n *\r\n * There are two important simplifications compared to the specification:\r\n *\r\n * 1. The handling of `useCapture` in `addEventListener` and\r\n *    `removeEventListener`. There is no real capture model.\r\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\r\n *    There is no event target hierarchy. When a listener calls\r\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\r\n *    more listeners after this one will be called. Same as when the listener\r\n *    returns false.\r\n */\r\nclass Target extends Disposable {\r\n  /**\r\n   * @param {*} [target] Default event target for dispatched events.\r\n   */\r\n  constructor(target) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {*}\r\n     */\r\n    this.eventTarget_ = target;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\r\n    this.pendingRemovals_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\r\n    this.dispatching_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>|null}\r\n     */\r\n    this.listeners_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\r\n  addEventListener(type, listener) {\r\n    if (!type || !listener) {\r\n      return;\r\n    }\r\n    const listeners = this.listeners_ || (this.listeners_ = {});\r\n    const listenersForType = listeners[type] || (listeners[type] = []);\r\n    if (!listenersForType.includes(listener)) {\r\n      listenersForType.push(listener);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatches an event and calls all listeners listening for events\r\n   * of this type. The event parameter can either be a string or an\r\n   * Object with a `type` property.\r\n   *\r\n   * @param {import(\"./Event.js\").default|string} event Event object.\r\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\r\n   *     event object or if any of the listeners returned false.\r\n   * @api\r\n   */\r\n  dispatchEvent(event) {\r\n    const isString = typeof event === 'string';\r\n    const type = isString ? event : event.type;\r\n    const listeners = this.listeners_ && this.listeners_[type];\r\n    if (!listeners) {\r\n      return;\r\n    }\r\n\r\n    const evt = isString ? new Event(event) : /** @type {Event} */ (event);\r\n    if (!evt.target) {\r\n      evt.target = this.eventTarget_ || this;\r\n    }\r\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\r\n    const pendingRemovals =\r\n      this.pendingRemovals_ || (this.pendingRemovals_ = {});\r\n    if (!(type in dispatching)) {\r\n      dispatching[type] = 0;\r\n      pendingRemovals[type] = 0;\r\n    }\r\n    ++dispatching[type];\r\n    let propagate;\r\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\r\n      if ('handleEvent' in listeners[i]) {\r\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */ (\r\n          listeners[i]\r\n        ).handleEvent(evt);\r\n      } else {\r\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (\r\n          listeners[i]\r\n        ).call(this, evt);\r\n      }\r\n      if (propagate === false || evt.propagationStopped) {\r\n        propagate = false;\r\n        break;\r\n      }\r\n    }\r\n    if (--dispatching[type] === 0) {\r\n      let pr = pendingRemovals[type];\r\n      delete pendingRemovals[type];\r\n      while (pr--) {\r\n        this.removeEventListener(type, VOID);\r\n      }\r\n      delete dispatching[type];\r\n    }\r\n    return propagate;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  disposeInternal() {\r\n    this.listeners_ && clear(this.listeners_);\r\n  }\r\n\r\n  /**\r\n   * Get the listeners for a specified event type. Listeners are returned in the\r\n   * order that they will be called in.\r\n   *\r\n   * @param {string} type Type.\r\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\r\n   */\r\n  getListeners(type) {\r\n    return (this.listeners_ && this.listeners_[type]) || undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {string} [type] Type. If not provided,\r\n   *     `true` will be returned if this event target has any listeners.\r\n   * @return {boolean} Has listeners.\r\n   */\r\n  hasListener(type) {\r\n    if (!this.listeners_) {\r\n      return false;\r\n    }\r\n    return type\r\n      ? type in this.listeners_\r\n      : Object.keys(this.listeners_).length > 0;\r\n  }\r\n\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\r\n  removeEventListener(type, listener) {\r\n    if (!this.listeners_) {\r\n      return;\r\n    }\r\n    const listeners = this.listeners_[type];\r\n    if (!listeners) {\r\n      return;\r\n    }\r\n    const index = listeners.indexOf(listener);\r\n    if (index !== -1) {\r\n      if (this.pendingRemovals_ && type in this.pendingRemovals_) {\r\n        // make listener a no-op, and remove later in #dispatchEvent()\r\n        listeners[index] = VOID;\r\n        ++this.pendingRemovals_[type];\r\n      } else {\r\n        listeners.splice(index, 1);\r\n        if (listeners.length === 0) {\r\n          delete this.listeners_[type];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Target;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}