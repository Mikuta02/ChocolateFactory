{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/render/canvas/style\r\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, computeGeometryType, newParsingContext } from '../../expr/expression.js';\nimport { buildExpression, newEvaluationContext } from '../../expr/cpu.js';\nimport { isEmpty } from '../../obj.js';\nimport { toSize } from '../../size.js';\n\n/**\r\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\r\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\r\n * and returns an instance of one of the expression classes.  The compiling step takes the\r\n * expression instance and returns a function that can be evaluated to return a literal value.  The\r\n * evaluator function should do as little allocation and work as possible.\r\n */\n\n/**\r\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\r\n */\n\n/**\r\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\r\n */\n\n/**\r\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\r\n */\n\n/**\r\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\r\n */\n\n/**\r\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\r\n */\n\n/**\r\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\r\n */\n\n/**\r\n * @param {EvaluationContext} context The evaluation context.\r\n * @return {boolean} Always true.\r\n */\nfunction always(context) {\n  return true;\n}\n\n/**\r\n * This function adapts a rule evaluator to the existing style function interface.\r\n * After we have deprecated the style function, we can use the compiled rules directly\r\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\r\n *\r\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\r\n * @return {import('../../style/Style.js').StyleFunction} A style function.\r\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    if (parsingContext.geometryType) {\n      evaluationContext.geometryType = computeGeometryType(feature.getGeometry());\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\r\n * This function adapts a style evaluator to the existing style function interface.\r\n * After we have deprecated the style function, we can use the compiled rules directly\r\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\r\n *\r\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\r\n * @return {import('../../style/Style.js').StyleFunction} A style function.\r\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\r\n   * @type {Array<StyleEvaluator>}\r\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\r\n   * @type {Array<Style>}\r\n   */\n  const styles = new Array(length);\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    let nonNullCount = 0;\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\r\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\r\n */\n\n/**\r\n * @typedef {Object} CompiledRule\r\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\r\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\r\n */\n\n/**\r\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {RuleSetEvaluator} The evaluator function.\r\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\r\n   * @type {Array<CompiledRule>}\r\n   */\n  const compiledRules = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter = 'filter' in rule ? buildExpression(rule.filter, BooleanType, context) : always;\n\n    /**\r\n     * @type {Array<StyleEvaluator>}\r\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n    compiledRules[i] = {\n      filter,\n      styles\n    };\n  }\n  return function (context) {\n    /**\r\n     * @type {Array<Style>}\r\n     */\n    const styles = [];\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n    return styles;\n  };\n}\n\n/**\r\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\r\n */\n\n/**\r\n * @param {FlatStyle} flatStyle A flat style literal.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\r\n * this function will be reused between invocations.\r\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));\n  }\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\r\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\r\n */\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} prefix The property prefix.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {FillEvaluator?} A function that evaluates to a fill.\r\n */\nfunction buildFill(flatStyle, prefix, context) {\n  let evaluateColor;\n  if (prefix + 'fill-pattern-src' in flatStyle) {\n    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);\n  } else {\n    evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);\n  }\n  if (!evaluateColor) {\n    return null;\n  }\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\r\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\r\n */\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} prefix The property prefix.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\r\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);\n  const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n  const evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);\n  const evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);\n  const evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);\n  const evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);\n  const evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n    return stroke;\n  };\n}\n\n/**\r\n * @typedef {function(EvaluationContext):Text} TextEvaluator\r\n */\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\r\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n  const evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);\n  const evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);\n  const evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);\n  const evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);\n  const evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n  const evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);\n  const evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);\n  const evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);\n\n  // The following properties are not currently settable\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const text = new Text({\n    declutterMode\n  });\n  return function (context) {\n    text.setText(evaluateValue(context));\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') {\n        throw new Error('Expected left, right, center, start, or end for text-align');\n      }\n      text.setTextAlign(textAlign);\n    }\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') {\n        throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');\n      }\n      text.setTextBaseline(textBaseline);\n    }\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n    return text;\n  };\n}\n\n/**\r\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\r\n */\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\r\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n  return null;\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\r\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');\n  const anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\r\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const radiusName = prefix + 'radius';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n  const radius = requireNumber(flatStyle[radiusName], radiusName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius2,\n    angle,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n    return shape;\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\r\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const circle = new Circle({\n    radius: 5,\n    // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n    return circle;\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\r\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\r\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\nfunction patternEvaluator(flatStyle, prefix, context) {\n  const srcEvaluator = stringEvaluator(flatStyle, prefix + 'pattern-src', context);\n  const offsetEvaluator = sizeEvaluator(flatStyle, prefix + 'pattern-offset', context);\n  const patternSizeEvaluator = sizeEvaluator(flatStyle, prefix + 'pattern-size', context);\n  const colorEvaluator = colorLikeEvaluator(flatStyle, prefix + 'color', context);\n  return function (context) {\n    return {\n      src: srcEvaluator(context),\n      offset: offsetEvaluator && offsetEvaluator(context),\n      size: patternSizeEvaluator && patternSizeEvaluator(context),\n      color: colorEvaluator && colorEvaluator(context)\n    };\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\r\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\r\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], ColorType | StringType, context);\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\r\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\r\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.\r\n */\nfunction sizeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireSize(evaluator(context), name);\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\r\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType | NumberType, context);\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {number|undefined} A number or undefined.\r\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\r\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {string|undefined} A string or undefined.\r\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\r\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') {\n    throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);\n  }\n  return encoded;\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\r\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {Array<number>|undefined} An array of numbers or undefined.\r\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.\r\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\r\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>} An array of numbers.\r\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {string} A string.\r\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {number} A number.\r\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>|string} A color.\r\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>} A number or an array of two numbers.\r\n */\nfunction requireSize(value, property) {\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}\n\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {number|Array<number>} A number or an array of two numbers.\r\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  return requireSize(value, property);\n}","map":{"version":3,"names":["Circle","Fill","Icon","RegularShape","Stroke","Style","Text","BooleanType","ColorType","NumberArrayType","NumberType","StringType","computeGeometryType","newParsingContext","buildExpression","newEvaluationContext","isEmpty","toSize","always","context","rulesToStyleFunction","rules","parsingContext","evaluator","buildRuleSet","evaluationContext","feature","resolution","properties","getPropertiesInternal","featureId","id","getId","undefined","geometryType","getGeometry","flatStylesToStyleFunction","flatStyles","length","evaluators","Array","i","buildStyle","styles","nonNullCount","style","compiledRules","rule","filter","isArray","styleLength","j","someMatched","filterEvaluator","else","styleEvaluator","push","flatStyle","evaluateFill","buildFill","evaluateStroke","buildStroke","evaluateText","buildText","evaluateImage","buildImage","evaluateZIndex","numberEvaluator","Error","JSON","stringify","empty","fill","setFill","stroke","setStroke","text","setText","image","setImage","setZIndex","prefix","evaluateColor","patternEvaluator","colorLikeEvaluator","color","setColor","evaluateWidth","evaluateLineCap","stringEvaluator","evaluateLineJoin","evaluateLineDash","numberArrayEvaluator","evaluateLineDashOffset","evaluateMiterLimit","setWidth","lineCap","setLineCap","lineJoin","setLineJoin","setLineDash","setLineDashOffset","setMiterLimit","evaluateValue","evaluateBackgroundFill","evaluateBackgroundStroke","evaluateFont","evaluateMaxAngle","evaluateOffsetX","evaluateOffsetY","evaluateOverflow","booleanEvaluator","evaluatePlacement","evaluateRepeat","evaluateScale","sizeLikeEvaluator","evaluateRotateWithView","evaluateRotation","evaluateAlign","evaluateJustify","evaluateBaseline","evaluatePadding","declutterMode","optionalDeclutterMode","setBackgroundFill","setBackgroundStroke","setFont","setMaxAngle","setOffsetX","setOffsetY","setOverflow","placement","setPlacement","setRepeat","setScale","setRotateWithView","setRotation","textAlign","setTextAlign","justify","setJustify","textBaseline","setTextBaseline","setPadding","buildIcon","buildShape","buildCircle","srcName","src","requireString","evaluateAnchor","coordinateEvaluator","evaluateOpacity","evaluateDisplacement","anchorOrigin","optionalIconOrigin","anchorXUnits","optionalIconAnchorUnits","anchorYUnits","optionalColorLike","crossOrigin","optionalString","offset","optionalNumberArray","offsetOrigin","width","optionalNumber","height","size","optionalSize","icon","setOpacity","setDisplacement","setAnchor","pointsName","radiusName","points","requireNumber","radius","radius2","angle","shape","evaluateRadius","circle","setRadius","name","srcEvaluator","offsetEvaluator","sizeEvaluator","patternSizeEvaluator","colorEvaluator","value","requireColorLike","requireNumberArray","array","requireSize","requireSizeLike","property","encoded"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/render/canvas/style.js"],"sourcesContent":["/**\r\n * @module ol/render/canvas/style\r\n */\r\n\r\nimport Circle from '../../style/Circle.js';\r\nimport Fill from '../../style/Fill.js';\r\nimport Icon from '../../style/Icon.js';\r\nimport RegularShape from '../../style/RegularShape.js';\r\nimport Stroke from '../../style/Stroke.js';\r\nimport Style from '../../style/Style.js';\r\nimport Text from '../../style/Text.js';\r\nimport {\r\n  BooleanType,\r\n  ColorType,\r\n  NumberArrayType,\r\n  NumberType,\r\n  StringType,\r\n  computeGeometryType,\r\n  newParsingContext,\r\n} from '../../expr/expression.js';\r\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\r\nimport {isEmpty} from '../../obj.js';\r\nimport {toSize} from '../../size.js';\r\n\r\n/**\r\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\r\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\r\n * and returns an instance of one of the expression classes.  The compiling step takes the\r\n * expression instance and returns a function that can be evaluated to return a literal value.  The\r\n * evaluator function should do as little allocation and work as possible.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\r\n */\r\n\r\n/**\r\n * @param {EvaluationContext} context The evaluation context.\r\n * @return {boolean} Always true.\r\n */\r\nfunction always(context) {\r\n  return true;\r\n}\r\n\r\n/**\r\n * This function adapts a rule evaluator to the existing style function interface.\r\n * After we have deprecated the style function, we can use the compiled rules directly\r\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\r\n *\r\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\r\n * @return {import('../../style/Style.js').StyleFunction} A style function.\r\n */\r\nexport function rulesToStyleFunction(rules) {\r\n  const parsingContext = newParsingContext();\r\n  const evaluator = buildRuleSet(rules, parsingContext);\r\n  const evaluationContext = newEvaluationContext();\r\n  return function (feature, resolution) {\r\n    evaluationContext.properties = feature.getPropertiesInternal();\r\n    evaluationContext.resolution = resolution;\r\n    if (parsingContext.featureId) {\r\n      const id = feature.getId();\r\n      if (id !== undefined) {\r\n        evaluationContext.featureId = id;\r\n      } else {\r\n        evaluationContext.featureId = null;\r\n      }\r\n    }\r\n    if (parsingContext.geometryType) {\r\n      evaluationContext.geometryType = computeGeometryType(\r\n        feature.getGeometry(),\r\n      );\r\n    }\r\n    return evaluator(evaluationContext);\r\n  };\r\n}\r\n\r\n/**\r\n * This function adapts a style evaluator to the existing style function interface.\r\n * After we have deprecated the style function, we can use the compiled rules directly\r\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\r\n *\r\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\r\n * @return {import('../../style/Style.js').StyleFunction} A style function.\r\n */\r\nexport function flatStylesToStyleFunction(flatStyles) {\r\n  const parsingContext = newParsingContext();\r\n  const length = flatStyles.length;\r\n\r\n  /**\r\n   * @type {Array<StyleEvaluator>}\r\n   */\r\n  const evaluators = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\r\n  }\r\n  const evaluationContext = newEvaluationContext();\r\n\r\n  /**\r\n   * @type {Array<Style>}\r\n   */\r\n  const styles = new Array(length);\r\n\r\n  return function (feature, resolution) {\r\n    evaluationContext.properties = feature.getPropertiesInternal();\r\n    evaluationContext.resolution = resolution;\r\n    if (parsingContext.featureId) {\r\n      const id = feature.getId();\r\n      if (id !== undefined) {\r\n        evaluationContext.featureId = id;\r\n      } else {\r\n        evaluationContext.featureId = null;\r\n      }\r\n    }\r\n    let nonNullCount = 0;\r\n    for (let i = 0; i < length; ++i) {\r\n      const style = evaluators[i](evaluationContext);\r\n      if (style) {\r\n        styles[nonNullCount] = style;\r\n        nonNullCount += 1;\r\n      }\r\n    }\r\n    styles.length = nonNullCount;\r\n    return styles;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompiledRule\r\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\r\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\r\n */\r\n\r\n/**\r\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {RuleSetEvaluator} The evaluator function.\r\n */\r\nexport function buildRuleSet(rules, context) {\r\n  const length = rules.length;\r\n\r\n  /**\r\n   * @type {Array<CompiledRule>}\r\n   */\r\n  const compiledRules = new Array(length);\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    const rule = rules[i];\r\n    const filter =\r\n      'filter' in rule\r\n        ? buildExpression(rule.filter, BooleanType, context)\r\n        : always;\r\n\r\n    /**\r\n     * @type {Array<StyleEvaluator>}\r\n     */\r\n    let styles;\r\n    if (Array.isArray(rule.style)) {\r\n      const styleLength = rule.style.length;\r\n      styles = new Array(styleLength);\r\n      for (let j = 0; j < styleLength; ++j) {\r\n        styles[j] = buildStyle(rule.style[j], context);\r\n      }\r\n    } else {\r\n      styles = [buildStyle(rule.style, context)];\r\n    }\r\n\r\n    compiledRules[i] = {filter, styles};\r\n  }\r\n\r\n  return function (context) {\r\n    /**\r\n     * @type {Array<Style>}\r\n     */\r\n    const styles = [];\r\n\r\n    let someMatched = false;\r\n    for (let i = 0; i < length; ++i) {\r\n      const filterEvaluator = compiledRules[i].filter;\r\n      if (!filterEvaluator(context)) {\r\n        continue;\r\n      }\r\n      if (rules[i].else && someMatched) {\r\n        continue;\r\n      }\r\n      someMatched = true;\r\n      for (const styleEvaluator of compiledRules[i].styles) {\r\n        const style = styleEvaluator(context);\r\n        if (!style) {\r\n          continue;\r\n        }\r\n        styles.push(style);\r\n      }\r\n    }\r\n\r\n    return styles;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle A flat style literal.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\r\n * this function will be reused between invocations.\r\n */\r\nexport function buildStyle(flatStyle, context) {\r\n  const evaluateFill = buildFill(flatStyle, '', context);\r\n  const evaluateStroke = buildStroke(flatStyle, '', context);\r\n  const evaluateText = buildText(flatStyle, context);\r\n  const evaluateImage = buildImage(flatStyle, context);\r\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\r\n\r\n  if (\r\n    !evaluateFill &&\r\n    !evaluateStroke &&\r\n    !evaluateText &&\r\n    !evaluateImage &&\r\n    !isEmpty(flatStyle)\r\n  ) {\r\n    // assume this is a user error\r\n    // would be nice to check the properties and suggest \"did you mean...\"\r\n    throw new Error(\r\n      'No fill, stroke, point, or text symbolizer properties in style: ' +\r\n        JSON.stringify(flatStyle),\r\n    );\r\n  }\r\n\r\n  const style = new Style();\r\n  return function (context) {\r\n    let empty = true;\r\n    if (evaluateFill) {\r\n      const fill = evaluateFill(context);\r\n      if (fill) {\r\n        empty = false;\r\n      }\r\n      style.setFill(fill);\r\n    }\r\n    if (evaluateStroke) {\r\n      const stroke = evaluateStroke(context);\r\n      if (stroke) {\r\n        empty = false;\r\n      }\r\n      style.setStroke(stroke);\r\n    }\r\n    if (evaluateText) {\r\n      const text = evaluateText(context);\r\n      if (text) {\r\n        empty = false;\r\n      }\r\n      style.setText(text);\r\n    }\r\n    if (evaluateImage) {\r\n      const image = evaluateImage(context);\r\n      if (image) {\r\n        empty = false;\r\n      }\r\n      style.setImage(image);\r\n    }\r\n    if (evaluateZIndex) {\r\n      style.setZIndex(evaluateZIndex(context));\r\n    }\r\n    if (empty) {\r\n      return null;\r\n    }\r\n    return style;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} prefix The property prefix.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {FillEvaluator?} A function that evaluates to a fill.\r\n */\r\nfunction buildFill(flatStyle, prefix, context) {\r\n  let evaluateColor;\r\n  if (prefix + 'fill-pattern-src' in flatStyle) {\r\n    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);\r\n  } else {\r\n    evaluateColor = colorLikeEvaluator(\r\n      flatStyle,\r\n      prefix + 'fill-color',\r\n      context,\r\n    );\r\n  }\r\n  if (!evaluateColor) {\r\n    return null;\r\n  }\r\n\r\n  const fill = new Fill();\r\n  return function (context) {\r\n    const color = evaluateColor(context);\r\n    if (color === 'none') {\r\n      return null;\r\n    }\r\n    fill.setColor(color);\r\n    return fill;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} prefix The property prefix.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\r\n */\r\nfunction buildStroke(flatStyle, prefix, context) {\r\n  const evaluateWidth = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-width',\r\n    context,\r\n  );\r\n\r\n  const evaluateColor = colorLikeEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-color',\r\n    context,\r\n  );\r\n\r\n  if (!evaluateWidth && !evaluateColor) {\r\n    return null;\r\n  }\r\n\r\n  const evaluateLineCap = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-cap',\r\n    context,\r\n  );\r\n\r\n  const evaluateLineJoin = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-join',\r\n    context,\r\n  );\r\n\r\n  const evaluateLineDash = numberArrayEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-dash',\r\n    context,\r\n  );\r\n\r\n  const evaluateLineDashOffset = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-dash-offset',\r\n    context,\r\n  );\r\n\r\n  const evaluateMiterLimit = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-miter-limit',\r\n    context,\r\n  );\r\n\r\n  const stroke = new Stroke();\r\n  return function (context) {\r\n    if (evaluateColor) {\r\n      const color = evaluateColor(context);\r\n      if (color === 'none') {\r\n        return null;\r\n      }\r\n      stroke.setColor(color);\r\n    }\r\n\r\n    if (evaluateWidth) {\r\n      stroke.setWidth(evaluateWidth(context));\r\n    }\r\n\r\n    if (evaluateLineCap) {\r\n      const lineCap = evaluateLineCap(context);\r\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\r\n        throw new Error('Expected butt, round, or square line cap');\r\n      }\r\n      stroke.setLineCap(lineCap);\r\n    }\r\n\r\n    if (evaluateLineJoin) {\r\n      const lineJoin = evaluateLineJoin(context);\r\n      if (\r\n        lineJoin !== 'bevel' &&\r\n        lineJoin !== 'round' &&\r\n        lineJoin !== 'miter'\r\n      ) {\r\n        throw new Error('Expected bevel, round, or miter line join');\r\n      }\r\n      stroke.setLineJoin(lineJoin);\r\n    }\r\n\r\n    if (evaluateLineDash) {\r\n      stroke.setLineDash(evaluateLineDash(context));\r\n    }\r\n\r\n    if (evaluateLineDashOffset) {\r\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\r\n    }\r\n\r\n    if (evaluateMiterLimit) {\r\n      stroke.setMiterLimit(evaluateMiterLimit(context));\r\n    }\r\n\r\n    return stroke;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Text} TextEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\r\n */\r\nfunction buildText(flatStyle, context) {\r\n  const prefix = 'text-';\r\n\r\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\r\n  // work with our expression syntax where arrays of strings are interpreted as\r\n  // call expressions.  To support rich text, we could add a 'strings' operator\r\n  // where all the following arguments would be string values.\r\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\r\n  if (!evaluateValue) {\r\n    return null;\r\n  }\r\n\r\n  const evaluateFill = buildFill(flatStyle, prefix, context);\r\n\r\n  const evaluateBackgroundFill = buildFill(\r\n    flatStyle,\r\n    prefix + 'background-',\r\n    context,\r\n  );\r\n\r\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\r\n\r\n  const evaluateBackgroundStroke = buildStroke(\r\n    flatStyle,\r\n    prefix + 'background-',\r\n    context,\r\n  );\r\n\r\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\r\n\r\n  const evaluateMaxAngle = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'max-angle',\r\n    context,\r\n  );\r\n\r\n  const evaluateOffsetX = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'offset-x',\r\n    context,\r\n  );\r\n\r\n  const evaluateOffsetY = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'offset-y',\r\n    context,\r\n  );\r\n\r\n  const evaluateOverflow = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'overflow',\r\n    context,\r\n  );\r\n\r\n  const evaluatePlacement = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'placement',\r\n    context,\r\n  );\r\n\r\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\r\n\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n\r\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\r\n\r\n  const evaluateJustify = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'justify',\r\n    context,\r\n  );\r\n\r\n  const evaluateBaseline = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'baseline',\r\n    context,\r\n  );\r\n\r\n  const evaluatePadding = numberArrayEvaluator(\r\n    flatStyle,\r\n    prefix + 'padding',\r\n    context,\r\n  );\r\n\r\n  // The following properties are not currently settable\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const text = new Text({declutterMode});\r\n\r\n  return function (context) {\r\n    text.setText(evaluateValue(context));\r\n\r\n    if (evaluateFill) {\r\n      text.setFill(evaluateFill(context));\r\n    }\r\n\r\n    if (evaluateBackgroundFill) {\r\n      text.setBackgroundFill(evaluateBackgroundFill(context));\r\n    }\r\n\r\n    if (evaluateStroke) {\r\n      text.setStroke(evaluateStroke(context));\r\n    }\r\n\r\n    if (evaluateBackgroundStroke) {\r\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\r\n    }\r\n\r\n    if (evaluateFont) {\r\n      text.setFont(evaluateFont(context));\r\n    }\r\n\r\n    if (evaluateMaxAngle) {\r\n      text.setMaxAngle(evaluateMaxAngle(context));\r\n    }\r\n\r\n    if (evaluateOffsetX) {\r\n      text.setOffsetX(evaluateOffsetX(context));\r\n    }\r\n\r\n    if (evaluateOffsetY) {\r\n      text.setOffsetY(evaluateOffsetY(context));\r\n    }\r\n\r\n    if (evaluateOverflow) {\r\n      text.setOverflow(evaluateOverflow(context));\r\n    }\r\n\r\n    if (evaluatePlacement) {\r\n      const placement = evaluatePlacement(context);\r\n      if (placement !== 'point' && placement !== 'line') {\r\n        throw new Error('Expected point or line for text-placement');\r\n      }\r\n      text.setPlacement(placement);\r\n    }\r\n\r\n    if (evaluateRepeat) {\r\n      text.setRepeat(evaluateRepeat(context));\r\n    }\r\n\r\n    if (evaluateScale) {\r\n      text.setScale(evaluateScale(context));\r\n    }\r\n\r\n    if (evaluateRotateWithView) {\r\n      text.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n\r\n    if (evaluateRotation) {\r\n      text.setRotation(evaluateRotation(context));\r\n    }\r\n\r\n    if (evaluateAlign) {\r\n      const textAlign = evaluateAlign(context);\r\n      if (\r\n        textAlign !== 'left' &&\r\n        textAlign !== 'center' &&\r\n        textAlign !== 'right' &&\r\n        textAlign !== 'end' &&\r\n        textAlign !== 'start'\r\n      ) {\r\n        throw new Error(\r\n          'Expected left, right, center, start, or end for text-align',\r\n        );\r\n      }\r\n      text.setTextAlign(textAlign);\r\n    }\r\n\r\n    if (evaluateJustify) {\r\n      const justify = evaluateJustify(context);\r\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\r\n        throw new Error('Expected left, right, or center for text-justify');\r\n      }\r\n      text.setJustify(justify);\r\n    }\r\n\r\n    if (evaluateBaseline) {\r\n      const textBaseline = evaluateBaseline(context);\r\n      if (\r\n        textBaseline !== 'bottom' &&\r\n        textBaseline !== 'top' &&\r\n        textBaseline !== 'middle' &&\r\n        textBaseline !== 'alphabetic' &&\r\n        textBaseline !== 'hanging'\r\n      ) {\r\n        throw new Error(\r\n          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline',\r\n        );\r\n      }\r\n      text.setTextBaseline(textBaseline);\r\n    }\r\n\r\n    if (evaluatePadding) {\r\n      text.setPadding(evaluatePadding(context));\r\n    }\r\n\r\n    return text;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\r\n */\r\nfunction buildImage(flatStyle, context) {\r\n  if ('icon-src' in flatStyle) {\r\n    return buildIcon(flatStyle, context);\r\n  }\r\n\r\n  if ('shape-points' in flatStyle) {\r\n    return buildShape(flatStyle, context);\r\n  }\r\n\r\n  if ('circle-radius' in flatStyle) {\r\n    return buildCircle(flatStyle, context);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\r\n */\r\nfunction buildIcon(flatStyle, context) {\r\n  const prefix = 'icon-';\r\n\r\n  // required property\r\n  const srcName = prefix + 'src';\r\n  const src = requireString(flatStyle[srcName], srcName);\r\n\r\n  // settable properties\r\n  const evaluateAnchor = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'anchor',\r\n    context,\r\n  );\r\n\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n\r\n  const evaluateOpacity = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'opacity',\r\n    context,\r\n  );\r\n\r\n  const evaluateDisplacement = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'displacement',\r\n    context,\r\n  );\r\n\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  // the remaining symbolizer properties are not currently settable\r\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\r\n  const anchorXUnits = optionalIconAnchorUnits(\r\n    flatStyle,\r\n    prefix + 'anchor-x-units',\r\n  );\r\n  const anchorYUnits = optionalIconAnchorUnits(\r\n    flatStyle,\r\n    prefix + 'anchor-y-units',\r\n  );\r\n  const color = optionalColorLike(flatStyle, prefix + 'color');\r\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\r\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\r\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\r\n  const width = optionalNumber(flatStyle, prefix + 'width');\r\n  const height = optionalNumber(flatStyle, prefix + 'height');\r\n  const size = optionalSize(flatStyle, prefix + 'size');\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const icon = new Icon({\r\n    src,\r\n    anchorOrigin,\r\n    anchorXUnits,\r\n    anchorYUnits,\r\n    color,\r\n    crossOrigin,\r\n    offset,\r\n    offsetOrigin,\r\n    height,\r\n    width,\r\n    size,\r\n    declutterMode,\r\n  });\r\n\r\n  return function (context) {\r\n    if (evaluateOpacity) {\r\n      icon.setOpacity(evaluateOpacity(context));\r\n    }\r\n\r\n    if (evaluateDisplacement) {\r\n      icon.setDisplacement(evaluateDisplacement(context));\r\n    }\r\n\r\n    if (evaluateRotation) {\r\n      icon.setRotation(evaluateRotation(context));\r\n    }\r\n\r\n    if (evaluateRotateWithView) {\r\n      icon.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n\r\n    if (evaluateScale) {\r\n      icon.setScale(evaluateScale(context));\r\n    }\r\n\r\n    if (evaluateAnchor) {\r\n      icon.setAnchor(evaluateAnchor(context));\r\n    }\r\n    return icon;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\r\n */\r\nfunction buildShape(flatStyle, context) {\r\n  const prefix = 'shape-';\r\n\r\n  // required property\r\n  const pointsName = prefix + 'points';\r\n  const radiusName = prefix + 'radius';\r\n  const points = requireNumber(flatStyle[pointsName], pointsName);\r\n  const radius = requireNumber(flatStyle[radiusName], radiusName);\r\n\r\n  // settable properties\r\n  const evaluateFill = buildFill(flatStyle, prefix, context);\r\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n  const evaluateDisplacement = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'displacement',\r\n    context,\r\n  );\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  // the remaining properties are not currently settable\r\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\r\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const shape = new RegularShape({\r\n    points,\r\n    radius,\r\n    radius2,\r\n    angle,\r\n    declutterMode,\r\n  });\r\n\r\n  return function (context) {\r\n    if (evaluateFill) {\r\n      shape.setFill(evaluateFill(context));\r\n    }\r\n    if (evaluateStroke) {\r\n      shape.setStroke(evaluateStroke(context));\r\n    }\r\n    if (evaluateDisplacement) {\r\n      shape.setDisplacement(evaluateDisplacement(context));\r\n    }\r\n    if (evaluateRotation) {\r\n      shape.setRotation(evaluateRotation(context));\r\n    }\r\n    if (evaluateRotateWithView) {\r\n      shape.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n    if (evaluateScale) {\r\n      shape.setScale(evaluateScale(context));\r\n    }\r\n\r\n    return shape;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\r\n */\r\nfunction buildCircle(flatStyle, context) {\r\n  const prefix = 'circle-';\r\n\r\n  // settable properties\r\n  const evaluateFill = buildFill(flatStyle, prefix, context);\r\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\r\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n  const evaluateDisplacement = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'displacement',\r\n    context,\r\n  );\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  // the remaining properties are not currently settable\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const circle = new Circle({\r\n    radius: 5, // this is arbitrary, but required - the evaluated radius is used below\r\n    declutterMode,\r\n  });\r\n\r\n  return function (context) {\r\n    if (evaluateRadius) {\r\n      circle.setRadius(evaluateRadius(context));\r\n    }\r\n    if (evaluateFill) {\r\n      circle.setFill(evaluateFill(context));\r\n    }\r\n    if (evaluateStroke) {\r\n      circle.setStroke(evaluateStroke(context));\r\n    }\r\n    if (evaluateDisplacement) {\r\n      circle.setDisplacement(evaluateDisplacement(context));\r\n    }\r\n    if (evaluateRotation) {\r\n      circle.setRotation(evaluateRotation(context));\r\n    }\r\n    if (evaluateRotateWithView) {\r\n      circle.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n    if (evaluateScale) {\r\n      circle.setScale(evaluateScale(context));\r\n    }\r\n\r\n    return circle;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\r\n */\r\nfunction numberEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return undefined;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\r\n  return function (context) {\r\n    return requireNumber(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\r\n */\r\nfunction stringEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\r\n  return function (context) {\r\n    return requireString(evaluator(context), name);\r\n  };\r\n}\r\n\r\nfunction patternEvaluator(flatStyle, prefix, context) {\r\n  const srcEvaluator = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'pattern-src',\r\n    context,\r\n  );\r\n  const offsetEvaluator = sizeEvaluator(\r\n    flatStyle,\r\n    prefix + 'pattern-offset',\r\n    context,\r\n  );\r\n  const patternSizeEvaluator = sizeEvaluator(\r\n    flatStyle,\r\n    prefix + 'pattern-size',\r\n    context,\r\n  );\r\n  const colorEvaluator = colorLikeEvaluator(\r\n    flatStyle,\r\n    prefix + 'color',\r\n    context,\r\n  );\r\n  return function (context) {\r\n    return {\r\n      src: srcEvaluator(context),\r\n      offset: offsetEvaluator && offsetEvaluator(context),\r\n      size: patternSizeEvaluator && patternSizeEvaluator(context),\r\n      color: colorEvaluator && colorEvaluator(context),\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\r\n */\r\nfunction booleanEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\r\n  return function (context) {\r\n    const value = evaluator(context);\r\n    if (typeof value !== 'boolean') {\r\n      throw new Error(`Expected a boolean for ${name}`);\r\n    }\r\n    return value;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\r\n */\r\nfunction colorLikeEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(\r\n    flatStyle[name],\r\n    ColorType | StringType,\r\n    context,\r\n  );\r\n  return function (context) {\r\n    return requireColorLike(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\r\n */\r\nfunction numberArrayEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\r\n  return function (context) {\r\n    return requireNumberArray(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\r\n */\r\nfunction coordinateEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\r\n  return function (context) {\r\n    const array = requireNumberArray(evaluator(context), name);\r\n    if (array.length !== 2) {\r\n      throw new Error(`Expected two numbers for ${name}`);\r\n    }\r\n    return array;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.\r\n */\r\nfunction sizeEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\r\n  return function (context) {\r\n    return requireSize(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\r\n */\r\nfunction sizeLikeEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(\r\n    flatStyle[name],\r\n    NumberArrayType | NumberType,\r\n    context,\r\n  );\r\n  return function (context) {\r\n    return requireSizeLike(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {number|undefined} A number or undefined.\r\n */\r\nfunction optionalNumber(flatStyle, property) {\r\n  const value = flatStyle[property];\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof value !== 'number') {\r\n    throw new Error(`Expected a number for ${property}`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\r\n */\r\nfunction optionalSize(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof encoded === 'number') {\r\n    return toSize(encoded);\r\n  }\r\n  if (!Array.isArray(encoded)) {\r\n    throw new Error(`Expected a number or size array for ${property}`);\r\n  }\r\n  if (\r\n    encoded.length !== 2 ||\r\n    typeof encoded[0] !== 'number' ||\r\n    typeof encoded[1] !== 'number'\r\n  ) {\r\n    throw new Error(`Expected a number or size array for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {string|undefined} A string or undefined.\r\n */\r\nfunction optionalString(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof encoded !== 'string') {\r\n    throw new Error(`Expected a string for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\r\n */\r\nfunction optionalIconOrigin(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (\r\n    encoded !== 'bottom-left' &&\r\n    encoded !== 'bottom-right' &&\r\n    encoded !== 'top-left' &&\r\n    encoded !== 'top-right'\r\n  ) {\r\n    throw new Error(\r\n      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`,\r\n    );\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\r\n */\r\nfunction optionalIconAnchorUnits(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\r\n    throw new Error(`Expected pixels or fraction for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {Array<number>|undefined} An array of numbers or undefined.\r\n */\r\nfunction optionalNumberArray(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  return requireNumberArray(encoded, property);\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.\r\n */\r\nfunction optionalDeclutterMode(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof encoded !== 'string') {\r\n    throw new Error(`Expected a string for ${property}`);\r\n  }\r\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\r\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\r\n */\r\nfunction optionalColorLike(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  return requireColorLike(encoded, property);\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>} An array of numbers.\r\n */\r\nfunction requireNumberArray(value, property) {\r\n  if (!Array.isArray(value)) {\r\n    throw new Error(`Expected an array for ${property}`);\r\n  }\r\n  const length = value.length;\r\n  for (let i = 0; i < length; ++i) {\r\n    if (typeof value[i] !== 'number') {\r\n      throw new Error(`Expected an array of numbers for ${property}`);\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {string} A string.\r\n */\r\nfunction requireString(value, property) {\r\n  if (typeof value !== 'string') {\r\n    throw new Error(`Expected a string for ${property}`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {number} A number.\r\n */\r\nfunction requireNumber(value, property) {\r\n  if (typeof value !== 'number') {\r\n    throw new Error(`Expected a number for ${property}`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>|string} A color.\r\n */\r\nfunction requireColorLike(value, property) {\r\n  if (typeof value === 'string') {\r\n    return value;\r\n  }\r\n  const array = requireNumberArray(value, property);\r\n  const length = array.length;\r\n  if (length < 3 || length > 4) {\r\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>} A number or an array of two numbers.\r\n */\r\nfunction requireSize(value, property) {\r\n  const size = requireNumberArray(value, property);\r\n  if (size.length !== 2) {\r\n    throw new Error(`Expected an array of two numbers for ${property}`);\r\n  }\r\n  return size;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {number|Array<number>} A number or an array of two numbers.\r\n */\r\nfunction requireSizeLike(value, property) {\r\n  if (typeof value === 'number') {\r\n    return value;\r\n  }\r\n  return requireSize(value, property);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}