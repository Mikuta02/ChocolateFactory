{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/tilegrid/WMTS\r\n */\n\nimport TileGrid from './TileGrid.js';\nimport { get as getProjection } from '../proj.js';\n\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\r\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\r\n * When no `origin` or `origins` are configured, the `origin` will be set to the\r\n * top-left corner of the extent.\r\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\r\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\r\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\r\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\r\n * given, the array length should match the length of the `resolutions` array, i.e.\r\n * each resolution can have a different origin. Tile coordinates increase left to\r\n * right and downwards. If not specified, `extent` or `origin` must be provided.\r\n * @property {!Array<number>} resolutions Resolutions. The array index of each\r\n * resolution needs to match the zoom level. This means that even if a `minZoom`\r\n * is configured, the resolutions array will have a length of `maxZoom + 1`\r\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\r\n * to match the length of the `resolutions` array.\r\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\r\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\r\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\r\n * define each zoom level's extent together with the `origin` or `origins`.\r\n * A grid `extent` can be configured in addition, and will further limit the extent for\r\n * which tile requests are made by sources. If the bottom-left corner of\r\n * an extent is used as `origin` or `origins`, then the `y` value must be\r\n * negative because OpenLayers tile coordinates use the top left as the origin.\r\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\r\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\r\n * this array needs to match the length of the `resolutions` array.\r\n */\n\n/**\r\n * @classdesc\r\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\r\n * @api\r\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\r\n   * @param {Options} options WMTS options.\r\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes\n    });\n\n    /**\r\n     * @private\r\n     * @type {!Array<string>}\r\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\r\n   * @param {number} z Z.\r\n   * @return {string} MatrixId..\r\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\r\n   * Get the list of matrix identifiers.\r\n   * @return {Array<string>} MatrixIds.\r\n   * @api\r\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\nexport default WMTSTileGrid;\n\n/**\r\n * Create a tile grid from a WMTS capabilities matrix set and an\r\n * optional TileMatrixSetLimits.\r\n * @param {Object} matrixSet An object representing a matrixSet in the\r\n *     capabilities document.\r\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\r\n *     ranges the server provides.\r\n * @param {Array<Object>} [matrixLimits] An optional object representing\r\n *     the available matrices for tileGrid.\r\n * @return {WMTSTileGrid} WMTS tileGrid instance.\r\n * @api\r\n */\nexport function createFromCapabilitiesMatrixSet(matrixSet, extent, matrixLimits) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (!elt[identifierPropName].includes(':')) {\n          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes\n  });\n}","map":{"version":3,"names":["TileGrid","get","getProjection","WMTSTileGrid","constructor","options","extent","origin","origins","resolutions","tileSize","tileSizes","sizes","matrixIds_","matrixIds","getMatrixId","z","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","matrixLimits","undefined","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","projection","metersPerUnit","getMetersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","b","forEach","elt","matrixAvailable","length","find","elt_ml","includes","push","resolution","tileWidth","tileHeight"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/tilegrid/WMTS.js"],"sourcesContent":["/**\r\n * @module ol/tilegrid/WMTS\r\n */\r\n\r\nimport TileGrid from './TileGrid.js';\r\nimport {get as getProjection} from '../proj.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\r\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\r\n * When no `origin` or `origins` are configured, the `origin` will be set to the\r\n * top-left corner of the extent.\r\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\r\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\r\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\r\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\r\n * given, the array length should match the length of the `resolutions` array, i.e.\r\n * each resolution can have a different origin. Tile coordinates increase left to\r\n * right and downwards. If not specified, `extent` or `origin` must be provided.\r\n * @property {!Array<number>} resolutions Resolutions. The array index of each\r\n * resolution needs to match the zoom level. This means that even if a `minZoom`\r\n * is configured, the resolutions array will have a length of `maxZoom + 1`\r\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\r\n * to match the length of the `resolutions` array.\r\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\r\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\r\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\r\n * define each zoom level's extent together with the `origin` or `origins`.\r\n * A grid `extent` can be configured in addition, and will further limit the extent for\r\n * which tile requests are made by sources. If the bottom-left corner of\r\n * an extent is used as `origin` or `origins`, then the `y` value must be\r\n * negative because OpenLayers tile coordinates use the top left as the origin.\r\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\r\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\r\n * this array needs to match the length of the `resolutions` array.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\r\n * @api\r\n */\r\nclass WMTSTileGrid extends TileGrid {\r\n  /**\r\n   * @param {Options} options WMTS options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      extent: options.extent,\r\n      origin: options.origin,\r\n      origins: options.origins,\r\n      resolutions: options.resolutions,\r\n      tileSize: options.tileSize,\r\n      tileSizes: options.tileSizes,\r\n      sizes: options.sizes,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<string>}\r\n     */\r\n    this.matrixIds_ = options.matrixIds;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Z.\r\n   * @return {string} MatrixId..\r\n   */\r\n  getMatrixId(z) {\r\n    return this.matrixIds_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the list of matrix identifiers.\r\n   * @return {Array<string>} MatrixIds.\r\n   * @api\r\n   */\r\n  getMatrixIds() {\r\n    return this.matrixIds_;\r\n  }\r\n}\r\n\r\nexport default WMTSTileGrid;\r\n\r\n/**\r\n * Create a tile grid from a WMTS capabilities matrix set and an\r\n * optional TileMatrixSetLimits.\r\n * @param {Object} matrixSet An object representing a matrixSet in the\r\n *     capabilities document.\r\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\r\n *     ranges the server provides.\r\n * @param {Array<Object>} [matrixLimits] An optional object representing\r\n *     the available matrices for tileGrid.\r\n * @return {WMTSTileGrid} WMTS tileGrid instance.\r\n * @api\r\n */\r\nexport function createFromCapabilitiesMatrixSet(\r\n  matrixSet,\r\n  extent,\r\n  matrixLimits,\r\n) {\r\n  /** @type {!Array<number>} */\r\n  const resolutions = [];\r\n  /** @type {!Array<string>} */\r\n  const matrixIds = [];\r\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\r\n  const origins = [];\r\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\r\n  const tileSizes = [];\r\n  /** @type {!Array<import(\"../size.js\").Size>} */\r\n  const sizes = [];\r\n\r\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\r\n\r\n  const supportedCRSPropName = 'SupportedCRS';\r\n  const matrixIdsPropName = 'TileMatrix';\r\n  const identifierPropName = 'Identifier';\r\n  const scaleDenominatorPropName = 'ScaleDenominator';\r\n  const topLeftCornerPropName = 'TopLeftCorner';\r\n  const tileWidthPropName = 'TileWidth';\r\n  const tileHeightPropName = 'TileHeight';\r\n\r\n  const code = matrixSet[supportedCRSPropName];\r\n  const projection = getProjection(code);\r\n  const metersPerUnit = projection.getMetersPerUnit();\r\n  // swap origin x and y coordinates if axis orientation is lat/long\r\n  const switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\r\n\r\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\r\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\r\n  });\r\n\r\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\r\n    let matrixAvailable;\r\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\r\n    // TileMatrixSet from unavailable matrix levels.\r\n    if (matrixLimits.length > 0) {\r\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\r\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\r\n          return true;\r\n        }\r\n        // Fallback for tileMatrix identifiers that don't get prefixed\r\n        // by their tileMatrixSet identifiers.\r\n        if (!elt[identifierPropName].includes(':')) {\r\n          return (\r\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\r\n            elt_ml[matrixIdsPropName]\r\n          );\r\n        }\r\n        return false;\r\n      });\r\n    } else {\r\n      matrixAvailable = true;\r\n    }\r\n\r\n    if (matrixAvailable) {\r\n      matrixIds.push(elt[identifierPropName]);\r\n      const resolution =\r\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\r\n      const tileWidth = elt[tileWidthPropName];\r\n      const tileHeight = elt[tileHeightPropName];\r\n      if (switchOriginXY) {\r\n        origins.push([\r\n          elt[topLeftCornerPropName][1],\r\n          elt[topLeftCornerPropName][0],\r\n        ]);\r\n      } else {\r\n        origins.push(elt[topLeftCornerPropName]);\r\n      }\r\n      resolutions.push(resolution);\r\n      tileSizes.push(\r\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight],\r\n      );\r\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\r\n    }\r\n  });\r\n\r\n  return new WMTSTileGrid({\r\n    extent: extent,\r\n    origins: origins,\r\n    resolutions: resolutions,\r\n    matrixIds: matrixIds,\r\n    tileSizes: tileSizes,\r\n    sizes: sizes,\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}