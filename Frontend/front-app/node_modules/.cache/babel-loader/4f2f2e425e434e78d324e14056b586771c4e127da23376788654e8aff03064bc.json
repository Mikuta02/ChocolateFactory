{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * @module ol/render/canvas/PolygonBuilder\r\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, closePathInstruction, fillInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultFillStyle, defaultLineDash, defaultLineDashOffset } from '../canvas.js';\nimport { snap } from '../../geom/flat/simplify.js';\nclass CanvasPolygonBuilder extends CanvasBuilder {\n  /**\r\n   * @param {number} tolerance Tolerance.\r\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n\n  /**\r\n   * @param {Array<number>} flatCoordinates Flat coordinates.\r\n   * @param {number} offset Offset.\r\n   * @param {Array<number>} ends Ends.\r\n   * @param {number} stride Stride.\r\n   * @private\r\n   * @return {number} End.\r\n   */\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    const state = this.state;\n    const fill = state.fillStyle !== undefined;\n    const stroke = state.strokeStyle !== undefined;\n    const numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (let i = 0; i < numEnds; ++i) {\n      const end = ends[i];\n      const myBegin = this.coordinates.length;\n      const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset;\n  }\n\n  /**\r\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\r\n   * @param {import(\"../../Feature.js\").default} feature Feature.\r\n   * @param {number} [index] Render order index.\r\n   */\n  drawCircle(circleGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature, index);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset]);\n    }\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\n    const stride = circleGeometry.getStride();\n    const myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\r\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\r\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n   * @param {number} [index] Render order index.\r\n   */\n  drawPolygon(polygonGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature, index);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset]);\n    }\n    const ends = polygonGeometry.getEnds();\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    const stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ends, stride);\n    this.endGeometry(feature);\n  }\n\n  /**\r\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\r\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n   * @param {number} [index] Render order index.\r\n   */\n  drawMultiPolygon(multiPolygonGeometry, feature, index) {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    const strokeStyle = state.strokeStyle;\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature, index);\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset]);\n    }\n    const endss = multiPolygonGeometry.getEndss();\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    const stride = multiPolygonGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\r\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\r\n   */\n  finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n    const tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      const coordinates = this.coordinates;\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = snap(coordinates[i], tolerance);\n      }\n    }\n    return super.finish();\n  }\n\n  /**\r\n   * @private\r\n   */\n  setFillStrokeStyles_() {\n    const state = this.state;\n    const fillStyle = state.fillStyle;\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill);\n    }\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  }\n}\nexport default CanvasPolygonBuilder;","map":{"version":3,"names":["CanvasBuilder","CanvasInstruction","beginPathInstruction","closePathInstruction","fillInstruction","strokeInstruction","defaultFillStyle","defaultLineDash","defaultLineDashOffset","snap","CanvasPolygonBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","drawFlatCoordinatess_","flatCoordinates","offset","ends","stride","state","fill","fillStyle","undefined","stroke","strokeStyle","numEnds","length","instructions","push","hitDetectionInstructions","i","end","myBegin","coordinates","myEnd","appendFlatLineCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","drawCircle","circleGeometry","feature","index","setFillStrokeStyles_","beginGeometry","SET_FILL_STYLE","SET_STROKE_STYLE","lineWidth","lineCap","lineJoin","miterLimit","getFlatCoordinates","getStride","circleInstruction","CIRCLE","endGeometry","drawPolygon","polygonGeometry","getEnds","getOrientedFlatCoordinates","drawMultiPolygon","multiPolygonGeometry","endss","getEndss","ii","finish","reverseHitDetectionInstructions","updateFillStyle","createFill","updateStrokeStyle","applyStroke"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/render/canvas/PolygonBuilder.js"],"sourcesContent":["/**\r\n * @module ol/render/canvas/PolygonBuilder\r\n */\r\nimport CanvasBuilder from './Builder.js';\r\nimport CanvasInstruction, {\r\n  beginPathInstruction,\r\n  closePathInstruction,\r\n  fillInstruction,\r\n  strokeInstruction,\r\n} from './Instruction.js';\r\nimport {\r\n  defaultFillStyle,\r\n  defaultLineDash,\r\n  defaultLineDashOffset,\r\n} from '../canvas.js';\r\nimport {snap} from '../../geom/flat/simplify.js';\r\n\r\nclass CanvasPolygonBuilder extends CanvasBuilder {\r\n  /**\r\n   * @param {number} tolerance Tolerance.\r\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   */\r\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\r\n    super(tolerance, maxExtent, resolution, pixelRatio);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<number>} flatCoordinates Flat coordinates.\r\n   * @param {number} offset Offset.\r\n   * @param {Array<number>} ends Ends.\r\n   * @param {number} stride Stride.\r\n   * @private\r\n   * @return {number} End.\r\n   */\r\n  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\r\n    const state = this.state;\r\n    const fill = state.fillStyle !== undefined;\r\n    const stroke = state.strokeStyle !== undefined;\r\n    const numEnds = ends.length;\r\n    this.instructions.push(beginPathInstruction);\r\n    this.hitDetectionInstructions.push(beginPathInstruction);\r\n    for (let i = 0; i < numEnds; ++i) {\r\n      const end = ends[i];\r\n      const myBegin = this.coordinates.length;\r\n      const myEnd = this.appendFlatLineCoordinates(\r\n        flatCoordinates,\r\n        offset,\r\n        end,\r\n        stride,\r\n        true,\r\n        !stroke,\r\n      );\r\n      const moveToLineToInstruction = [\r\n        CanvasInstruction.MOVE_TO_LINE_TO,\r\n        myBegin,\r\n        myEnd,\r\n      ];\r\n      this.instructions.push(moveToLineToInstruction);\r\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\r\n      if (stroke) {\r\n        // Performance optimization: only call closePath() when we have a stroke.\r\n        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).\r\n        this.instructions.push(closePathInstruction);\r\n        this.hitDetectionInstructions.push(closePathInstruction);\r\n      }\r\n      offset = end;\r\n    }\r\n    if (fill) {\r\n      this.instructions.push(fillInstruction);\r\n      this.hitDetectionInstructions.push(fillInstruction);\r\n    }\r\n    if (stroke) {\r\n      this.instructions.push(strokeInstruction);\r\n      this.hitDetectionInstructions.push(strokeInstruction);\r\n    }\r\n    return offset;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../geom/Circle.js\").default} circleGeometry Circle geometry.\r\n   * @param {import(\"../../Feature.js\").default} feature Feature.\r\n   * @param {number} [index] Render order index.\r\n   */\r\n  drawCircle(circleGeometry, feature, index) {\r\n    const state = this.state;\r\n    const fillStyle = state.fillStyle;\r\n    const strokeStyle = state.strokeStyle;\r\n    if (fillStyle === undefined && strokeStyle === undefined) {\r\n      return;\r\n    }\r\n    this.setFillStrokeStyles_();\r\n    this.beginGeometry(circleGeometry, feature, index);\r\n    if (state.fillStyle !== undefined) {\r\n      this.hitDetectionInstructions.push([\r\n        CanvasInstruction.SET_FILL_STYLE,\r\n        defaultFillStyle,\r\n      ]);\r\n    }\r\n    if (state.strokeStyle !== undefined) {\r\n      this.hitDetectionInstructions.push([\r\n        CanvasInstruction.SET_STROKE_STYLE,\r\n        state.strokeStyle,\r\n        state.lineWidth,\r\n        state.lineCap,\r\n        state.lineJoin,\r\n        state.miterLimit,\r\n        defaultLineDash,\r\n        defaultLineDashOffset,\r\n      ]);\r\n    }\r\n    const flatCoordinates = circleGeometry.getFlatCoordinates();\r\n    const stride = circleGeometry.getStride();\r\n    const myBegin = this.coordinates.length;\r\n    this.appendFlatLineCoordinates(\r\n      flatCoordinates,\r\n      0,\r\n      flatCoordinates.length,\r\n      stride,\r\n      false,\r\n      false,\r\n    );\r\n    const circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\r\n    this.instructions.push(beginPathInstruction, circleInstruction);\r\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\r\n    if (state.fillStyle !== undefined) {\r\n      this.instructions.push(fillInstruction);\r\n      this.hitDetectionInstructions.push(fillInstruction);\r\n    }\r\n    if (state.strokeStyle !== undefined) {\r\n      this.instructions.push(strokeInstruction);\r\n      this.hitDetectionInstructions.push(strokeInstruction);\r\n    }\r\n    this.endGeometry(feature);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../geom/Polygon.js\").default|import(\"../Feature.js\").default} polygonGeometry Polygon geometry.\r\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n   * @param {number} [index] Render order index.\r\n   */\r\n  drawPolygon(polygonGeometry, feature, index) {\r\n    const state = this.state;\r\n    const fillStyle = state.fillStyle;\r\n    const strokeStyle = state.strokeStyle;\r\n    if (fillStyle === undefined && strokeStyle === undefined) {\r\n      return;\r\n    }\r\n    this.setFillStrokeStyles_();\r\n    this.beginGeometry(polygonGeometry, feature, index);\r\n    if (state.fillStyle !== undefined) {\r\n      this.hitDetectionInstructions.push([\r\n        CanvasInstruction.SET_FILL_STYLE,\r\n        defaultFillStyle,\r\n      ]);\r\n    }\r\n    if (state.strokeStyle !== undefined) {\r\n      this.hitDetectionInstructions.push([\r\n        CanvasInstruction.SET_STROKE_STYLE,\r\n        state.strokeStyle,\r\n        state.lineWidth,\r\n        state.lineCap,\r\n        state.lineJoin,\r\n        state.miterLimit,\r\n        defaultLineDash,\r\n        defaultLineDashOffset,\r\n      ]);\r\n    }\r\n    const ends = polygonGeometry.getEnds();\r\n    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\r\n    const stride = polygonGeometry.getStride();\r\n    this.drawFlatCoordinatess_(\r\n      flatCoordinates,\r\n      0,\r\n      /** @type {Array<number>} */ (ends),\r\n      stride,\r\n    );\r\n    this.endGeometry(feature);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../geom/MultiPolygon.js\").default} multiPolygonGeometry MultiPolygon geometry.\r\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\r\n   * @param {number} [index] Render order index.\r\n   */\r\n  drawMultiPolygon(multiPolygonGeometry, feature, index) {\r\n    const state = this.state;\r\n    const fillStyle = state.fillStyle;\r\n    const strokeStyle = state.strokeStyle;\r\n    if (fillStyle === undefined && strokeStyle === undefined) {\r\n      return;\r\n    }\r\n    this.setFillStrokeStyles_();\r\n    this.beginGeometry(multiPolygonGeometry, feature, index);\r\n    if (state.fillStyle !== undefined) {\r\n      this.hitDetectionInstructions.push([\r\n        CanvasInstruction.SET_FILL_STYLE,\r\n        defaultFillStyle,\r\n      ]);\r\n    }\r\n    if (state.strokeStyle !== undefined) {\r\n      this.hitDetectionInstructions.push([\r\n        CanvasInstruction.SET_STROKE_STYLE,\r\n        state.strokeStyle,\r\n        state.lineWidth,\r\n        state.lineCap,\r\n        state.lineJoin,\r\n        state.miterLimit,\r\n        defaultLineDash,\r\n        defaultLineDashOffset,\r\n      ]);\r\n    }\r\n    const endss = multiPolygonGeometry.getEndss();\r\n    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\r\n    const stride = multiPolygonGeometry.getStride();\r\n    let offset = 0;\r\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n      offset = this.drawFlatCoordinatess_(\r\n        flatCoordinates,\r\n        offset,\r\n        endss[i],\r\n        stride,\r\n      );\r\n    }\r\n    this.endGeometry(feature);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\r\n   */\r\n  finish() {\r\n    this.reverseHitDetectionInstructions();\r\n    this.state = null;\r\n    // We want to preserve topology when drawing polygons.  Polygons are\r\n    // simplified using quantization and point elimination. However, we might\r\n    // have received a mix of quantized and non-quantized geometries, so ensure\r\n    // that all are quantized by quantizing all coordinates in the batch.\r\n    const tolerance = this.tolerance;\r\n    if (tolerance !== 0) {\r\n      const coordinates = this.coordinates;\r\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coordinates[i] = snap(coordinates[i], tolerance);\r\n      }\r\n    }\r\n    return super.finish();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  setFillStrokeStyles_() {\r\n    const state = this.state;\r\n    const fillStyle = state.fillStyle;\r\n    if (fillStyle !== undefined) {\r\n      this.updateFillStyle(state, this.createFill);\r\n    }\r\n    if (state.strokeStyle !== undefined) {\r\n      this.updateStrokeStyle(state, this.applyStroke);\r\n    }\r\n  }\r\n}\r\n\r\nexport default CanvasPolygonBuilder;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}