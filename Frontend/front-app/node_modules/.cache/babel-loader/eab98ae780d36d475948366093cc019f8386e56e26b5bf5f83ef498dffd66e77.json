{"ast":null,"code":"/**\r\n * @module ol/array\r\n */\n\n/**\r\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\r\n * https://github.com/darkskyapp/binary-search\r\n *\r\n * @param {Array<*>} haystack Items to search through.\r\n * @param {*} needle The item to look for.\r\n * @param {Function} [comparator] Comparator function.\r\n * @return {number} The index of the item if found, -1 if not.\r\n */\nexport function binarySearch(haystack, needle, comparator) {\n  let mid, cmp;\n  comparator = comparator || ascending;\n  let low = 0;\n  let high = haystack.length;\n  let found = false;\n  while (low < high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\r\n     * to double (which gives the wrong results). */\n    mid = low + (high - low >> 1);\n    cmp = +comparator(haystack[mid], needle);\n    if (cmp < 0.0) {\n      /* Too low. */\n      low = mid + 1;\n    } else {\n      /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n\n  /* Key not found. */\n  return found ? low : ~low;\n}\n\n/**\r\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is less than, equal to, or greater than the second.\r\n */\nexport function ascending(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n/**\r\n * Compare function sorting arrays in descending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is greater than, equal to, or less than the second.\r\n */\nexport function descending(a, b) {\n  return a < b ? 1 : a > b ? -1 : 0;\n}\n\n/**\r\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\r\n * of this type to determine which nearest resolution to use.\r\n *\r\n * This function takes a `{number}` representing a value between two array entries,\r\n * a `{number}` representing the value of the nearest higher entry and\r\n * a `{number}` representing the value of the nearest lower entry\r\n * as arguments and returns a `{number}`. If a negative number or zero is returned\r\n * the lower value will be used, if a positive number is returned the higher value\r\n * will be used.\r\n * @typedef {function(number, number, number): number} NearestDirectionFunction\r\n * @api\r\n */\n\n/**\r\n * @param {Array<number>} arr Array in descending order.\r\n * @param {number} target Target.\r\n * @param {number|NearestDirectionFunction} direction\r\n *    0 means return the nearest,\r\n *    > 0 means return the largest nearest,\r\n *    < 0 means return the smallest nearest.\r\n * @return {number} Index.\r\n */\nexport function linearFindNearest(arr, target, direction) {\n  if (arr[0] <= target) {\n    return 0;\n  }\n  const n = arr.length;\n  if (target <= arr[n - 1]) {\n    return n - 1;\n  }\n  if (typeof direction === 'function') {\n    for (let i = 1; i < n; ++i) {\n      const candidate = arr[i];\n      if (candidate === target) {\n        return i;\n      }\n      if (candidate < target) {\n        if (direction(target, arr[i - 1], candidate) > 0) {\n          return i - 1;\n        }\n        return i;\n      }\n    }\n    return n - 1;\n  }\n  if (direction > 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] < target) {\n        return i - 1;\n      }\n    }\n    return n - 1;\n  }\n  if (direction < 0) {\n    for (let i = 1; i < n; ++i) {\n      if (arr[i] <= target) {\n        return i;\n      }\n    }\n    return n - 1;\n  }\n  for (let i = 1; i < n; ++i) {\n    if (arr[i] == target) {\n      return i;\n    }\n    if (arr[i] < target) {\n      if (arr[i - 1] - target < target - arr[i]) {\n        return i - 1;\n      }\n      return i;\n    }\n  }\n  return n - 1;\n}\n\n/**\r\n * @param {Array<*>} arr Array.\r\n * @param {number} begin Begin index.\r\n * @param {number} end End index.\r\n */\nexport function reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    const tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\n\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\r\n * @template VALUE\r\n */\nexport function extend(arr, data) {\n  const extension = Array.isArray(data) ? data : [data];\n  const length = extension.length;\n  for (let i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n}\n\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {VALUE} obj The element to remove.\r\n * @template VALUE\r\n * @return {boolean} If the element was removed.\r\n */\nexport function remove(arr, obj) {\n  const i = arr.indexOf(obj);\n  const found = i > -1;\n  if (found) {\n    arr.splice(i, 1);\n  }\n  return found;\n}\n\n/**\r\n * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.\r\n * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.\r\n * @return {boolean} Whether the two arrays are equal.\r\n */\nexport function equals(arr1, arr2) {\n  const len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\r\n * Sort the passed array such that the relative order of equal elements is preserved.\r\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\r\n * @param {Array<*>} arr The array to sort (modifies original).\r\n * @param {!function(*, *): number} compareFnc Comparison function.\r\n * @api\r\n */\nexport function stableSort(arr, compareFnc) {\n  const length = arr.length;\n  const tmp = Array(arr.length);\n  let i;\n  for (i = 0; i < length; i++) {\n    tmp[i] = {\n      index: i,\n      value: arr[i]\n    };\n  }\n  tmp.sort(function (a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n}\n\n/**\r\n * @param {Array<*>} arr The array to test.\r\n * @param {Function} [func] Comparison function.\r\n * @param {boolean} [strict] Strictly sorted (default false).\r\n * @return {boolean} Return index.\r\n */\nexport function isSorted(arr, func, strict) {\n  const compare = func || ascending;\n  return arr.every(function (currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n    const res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || strict && res === 0);\n  });\n}","map":{"version":3,"names":["binarySearch","haystack","needle","comparator","mid","cmp","ascending","low","high","length","found","a","b","descending","linearFindNearest","arr","target","direction","n","i","candidate","reverseSubArray","begin","end","tmp","extend","data","extension","Array","isArray","remove","obj","indexOf","splice","equals","arr1","arr2","len1","stableSort","compareFnc","index","value","sort","isSorted","func","strict","compare","every","currentVal","res"],"sources":["C:/Programiranje/veb/projekat/chocolate-factoryapp/Frontend/front-app/node_modules/ol/array.js"],"sourcesContent":["/**\r\n * @module ol/array\r\n */\r\n\r\n/**\r\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\r\n * https://github.com/darkskyapp/binary-search\r\n *\r\n * @param {Array<*>} haystack Items to search through.\r\n * @param {*} needle The item to look for.\r\n * @param {Function} [comparator] Comparator function.\r\n * @return {number} The index of the item if found, -1 if not.\r\n */\r\nexport function binarySearch(haystack, needle, comparator) {\r\n  let mid, cmp;\r\n  comparator = comparator || ascending;\r\n  let low = 0;\r\n  let high = haystack.length;\r\n  let found = false;\r\n\r\n  while (low < high) {\r\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\r\n     * to double (which gives the wrong results). */\r\n    mid = low + ((high - low) >> 1);\r\n    cmp = +comparator(haystack[mid], needle);\r\n\r\n    if (cmp < 0.0) {\r\n      /* Too low. */\r\n      low = mid + 1;\r\n    } else {\r\n      /* Key found or too high */\r\n      high = mid;\r\n      found = !cmp;\r\n    }\r\n  }\r\n\r\n  /* Key not found. */\r\n  return found ? low : ~low;\r\n}\r\n\r\n/**\r\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is less than, equal to, or greater than the second.\r\n */\r\nexport function ascending(a, b) {\r\n  return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n\r\n/**\r\n * Compare function sorting arrays in descending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is greater than, equal to, or less than the second.\r\n */\r\nexport function descending(a, b) {\r\n  return a < b ? 1 : a > b ? -1 : 0;\r\n}\r\n\r\n/**\r\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\r\n * of this type to determine which nearest resolution to use.\r\n *\r\n * This function takes a `{number}` representing a value between two array entries,\r\n * a `{number}` representing the value of the nearest higher entry and\r\n * a `{number}` representing the value of the nearest lower entry\r\n * as arguments and returns a `{number}`. If a negative number or zero is returned\r\n * the lower value will be used, if a positive number is returned the higher value\r\n * will be used.\r\n * @typedef {function(number, number, number): number} NearestDirectionFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @param {Array<number>} arr Array in descending order.\r\n * @param {number} target Target.\r\n * @param {number|NearestDirectionFunction} direction\r\n *    0 means return the nearest,\r\n *    > 0 means return the largest nearest,\r\n *    < 0 means return the smallest nearest.\r\n * @return {number} Index.\r\n */\r\nexport function linearFindNearest(arr, target, direction) {\r\n  if (arr[0] <= target) {\r\n    return 0;\r\n  }\r\n\r\n  const n = arr.length;\r\n  if (target <= arr[n - 1]) {\r\n    return n - 1;\r\n  }\r\n\r\n  if (typeof direction === 'function') {\r\n    for (let i = 1; i < n; ++i) {\r\n      const candidate = arr[i];\r\n      if (candidate === target) {\r\n        return i;\r\n      }\r\n      if (candidate < target) {\r\n        if (direction(target, arr[i - 1], candidate) > 0) {\r\n          return i - 1;\r\n        }\r\n        return i;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  if (direction > 0) {\r\n    for (let i = 1; i < n; ++i) {\r\n      if (arr[i] < target) {\r\n        return i - 1;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  if (direction < 0) {\r\n    for (let i = 1; i < n; ++i) {\r\n      if (arr[i] <= target) {\r\n        return i;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  for (let i = 1; i < n; ++i) {\r\n    if (arr[i] == target) {\r\n      return i;\r\n    }\r\n    if (arr[i] < target) {\r\n      if (arr[i - 1] - target < target - arr[i]) {\r\n        return i - 1;\r\n      }\r\n      return i;\r\n    }\r\n  }\r\n  return n - 1;\r\n}\r\n\r\n/**\r\n * @param {Array<*>} arr Array.\r\n * @param {number} begin Begin index.\r\n * @param {number} end End index.\r\n */\r\nexport function reverseSubArray(arr, begin, end) {\r\n  while (begin < end) {\r\n    const tmp = arr[begin];\r\n    arr[begin] = arr[end];\r\n    arr[end] = tmp;\r\n    ++begin;\r\n    --end;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\r\n * @template VALUE\r\n */\r\nexport function extend(arr, data) {\r\n  const extension = Array.isArray(data) ? data : [data];\r\n  const length = extension.length;\r\n  for (let i = 0; i < length; i++) {\r\n    arr[arr.length] = extension[i];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {VALUE} obj The element to remove.\r\n * @template VALUE\r\n * @return {boolean} If the element was removed.\r\n */\r\nexport function remove(arr, obj) {\r\n  const i = arr.indexOf(obj);\r\n  const found = i > -1;\r\n  if (found) {\r\n    arr.splice(i, 1);\r\n  }\r\n  return found;\r\n}\r\n\r\n/**\r\n * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.\r\n * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.\r\n * @return {boolean} Whether the two arrays are equal.\r\n */\r\nexport function equals(arr1, arr2) {\r\n  const len1 = arr1.length;\r\n  if (len1 !== arr2.length) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len1; i++) {\r\n    if (arr1[i] !== arr2[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Sort the passed array such that the relative order of equal elements is preserved.\r\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\r\n * @param {Array<*>} arr The array to sort (modifies original).\r\n * @param {!function(*, *): number} compareFnc Comparison function.\r\n * @api\r\n */\r\nexport function stableSort(arr, compareFnc) {\r\n  const length = arr.length;\r\n  const tmp = Array(arr.length);\r\n  let i;\r\n  for (i = 0; i < length; i++) {\r\n    tmp[i] = {index: i, value: arr[i]};\r\n  }\r\n  tmp.sort(function (a, b) {\r\n    return compareFnc(a.value, b.value) || a.index - b.index;\r\n  });\r\n  for (i = 0; i < arr.length; i++) {\r\n    arr[i] = tmp[i].value;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<*>} arr The array to test.\r\n * @param {Function} [func] Comparison function.\r\n * @param {boolean} [strict] Strictly sorted (default false).\r\n * @return {boolean} Return index.\r\n */\r\nexport function isSorted(arr, func, strict) {\r\n  const compare = func || ascending;\r\n  return arr.every(function (currentVal, index) {\r\n    if (index === 0) {\r\n      return true;\r\n    }\r\n    const res = compare(arr[index - 1], currentVal);\r\n    return !(res > 0 || (strict && res === 0));\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}